<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Sorter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        // Fix for standard font loading error
        pdfjsLib.GlobalWorkerOptions.standardFontDataUrl = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/';
    </script>
    <style>
        :root {
            --bg-primary: #f4f6f9;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #4b4b6a;
            --accent-primary: #6a5acd;
            --accent-secondary: #4a4a6a;
            --button-primary: #4CAF50;
            --button-secondary: #2196F3;
            --button-danger: #FF6B6B;
            --button-warning: #FF9800;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --bg-primary: #16213e;
            --bg-secondary: #0f3460;
            --text-primary: #e5e5e5;
            --text-secondary: #c0c0c0;
            --accent-primary: #6a5acd;
            --accent-secondary: #7b68ee;
            --button-primary: #388E3C;
            --button-secondary: #1976D2;
            --button-danger: #FF5252;
            --button-warning: #F57C00;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; transition: all 0.3s ease; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .toggle-icons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toggle-icons button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 100%;
            max-width: 900px;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-primary); }
        h3 { margin-bottom: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            color: white;
            font-size: 0.9rem;
        }
        
        .button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--button-primary); }
        .btn-secondary { background-color: var(--button-secondary); }
        .btn-danger { background-color: var(--button-danger); }
        .btn-warning { background-color: var(--button-warning); }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            word-break: break-all;
        }

        .results-section { display: none; }
        
        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .tab-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .file-list {
            height: 300px;
            overflow-y: auto;
            background: rgba(0,0,0,0.02);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            cursor: pointer; /* Visual cue */
        }
        
        .file-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .file-item:last-child { border-bottom: none; }
        .reason-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-secondary);
            color: white;
            margin-left: 10px;
        }

        .loading { display: none; text-align: center; margin: 20px; }
        
        .phase-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        .phase-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding-bottom: 5px;
        }

        .phase-btn.active {
            color: var(--accent-primary);
            border-bottom: 3px solid var(--accent-primary);
            font-weight: bold;
        }

        #phase2-container { display: none; }

        /* Special coloring for categories */
        .cat-a { color: var(--button-danger); } /* Non-Editable */
        .cat-b { color: var(--button-primary); } /* Tickable */
        .cat-c { color: var(--button-warning); } /* Locked/Other */

    </style>
</head>
<body>
    <div class="toggle-icons">
        <button id="darkModeToggle">ðŸŒ“</button>
    </div>

    <div class="container">
        <h1>PDF Form Sorter</h1>
        
        <div class="phase-selector">
            <button class="phase-btn active" id="btnPhase1">1. Analyze & Export</button>
            <button class="phase-btn" id="btnPhase2">2. Move via CSV</button>
        </div>

        <!-- Phase 1: Analyze -->
        <div id="phase1-container">
            <div class="button-container">
                <button id="selectSourceBtn" class="button btn-secondary">Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay" class="status-box">No folder selected</div>

            <div style="text-align:center; margin-bottom:15px;">
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="subfolders" checked> Scan Subfolders Only
                </label>
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="root"> Scan Root Only
                </label>
                <label style="cursor:pointer;">
                    <input type="radio" name="scanMode" value="both"> Scan Both
                </label>
            </div>

            <div class="button-container">
                <button id="analyzeBtn" class="button btn-primary" disabled>Analyze PDFs</button>
                <button id="stopAnalyzeBtn" class="button btn-warning" style="display:none;">Stop Analysis</button>
                <button id="resetBtn1" class="button btn-danger">Reset</button>
            </div>

            <div id="loading1" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Processing..." width="40">
                <p id="loadingText1">Scanning...</p>
            </div>

            <div id="resultsArea" class="results-section">
                <div class="tab-container">
                    <button class="tab-btn active" onclick="showTab('A')">Folder A (Non-Editable) <span id="countA">0</span></button>
                    <button class="tab-btn" onclick="showTab('B')">Folder B (Office Use: tickable) <span id="countB">0</span></button>
                    <button class="tab-btn" onclick="showTab('C')">Folder C (Office Use: not tickable) <span id="countC">0</span></button>
                </div>

                <div id="listA" class="file-list"></div>
                <div id="listB" class="file-list" style="display:none"></div>
                <div id="listC" class="file-list" style="display:none"></div>

                <div class="button-container">
                    <button id="downloadCsvBtnA" class="button btn-danger" style="display:none;">Download Category A CSV</button>
                    <button id="downloadCsvBtnB" class="button btn-primary" style="display:none;">Download Category B CSV</button>
                    <button id="downloadCsvBtnC" class="button btn-warning" style="display:none;">Download Category C CSV</button>
                </div>
            </div>
        </div>

        <!-- Phase 2: Move -->
        <div id="phase2-container">
            <p style="text-align:center; color:var(--text-secondary); margin-bottom:20px;">
                Upload CSVs for the categories you wish to process. You can process one, two, or all three.
            </p>

            <div class="button-container">
                <button id="selectSourceBtn2" class="button btn-secondary">1. Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay2" class="status-box">No source folder selected</div>

            <style>
                .move-row {
                    display: grid;
                    grid-template-columns: 1fr 1.5fr 1.5fr;
                    gap: 15px;
                    align-items: center;
                    background: rgba(255,255,255,0.05);
                    padding: 15px;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    margin-bottom: 15px;
                }
                .move-row h3 {
                    margin: 0;
                    font-size: 1rem;
                    border: none;
                    text-align: left;
                }
                .file-status { font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px; }
            </style>

            <div style="margin-top:20px;">
                <!-- Row A -->
                <div class="move-row">
                    <div>
                        <h3 class="cat-a">Folder A<br><small>(Non-Editable)</small></h3>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvA" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (A)
                            <input type="file" id="csvInputA" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayA" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestA" class="button btn-danger" style="width:100%; font-size:0.8rem;" disabled>Select Folder A</button>
                        <div id="pathDestA" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row B -->
                <div class="move-row">
                    <div>
                        <h3 class="cat-b">Folder B<br><small>(Office Use: tickable)</small></h3>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvB" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (B)
                            <input type="file" id="csvInputB" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayB" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestB" class="button btn-primary" style="width:100%; font-size:0.8rem;" disabled>Select Folder B</button>
                        <div id="pathDestB" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row C -->
                <div class="move-row">
                    <div>
                        <h3 class="cat-c">Folder C<br><small>(Office Use: not tickable)</small></h3>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (C)
                            <input type="file" id="csvInputC" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayC" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestC" class="button btn-warning" style="width:100%; font-size:0.8rem;" disabled>Select Folder C</button>
                        <div id="pathDestC" class="file-status">Not Selected</div>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                    <input type="checkbox" id="generateSummaryCheckbox" checked>
                    Generate Summary CSV Report
                </label>
            </div>

            <div class="button-container">
                <button id="executeMoveBtn" class="button btn-primary" disabled>Execute Move</button>
                <button id="stopMoveBtn" class="button btn-warning" style="display:none;">Stop Move</button>
                <button id="resetBtn2" class="button btn-danger">Reset</button>
            </div>

             <div id="loading2" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Moving..." width="40">
                <p id="loadingText2">Moving files...</p>
            </div>

            <div id="moveLog" class="file-list" style="display:none; height: 200px;"></div>
        </div>

    </div>

    <script>
        // --- State Management ---
        let sourceDirHandle = null;
        let allFiles = []; // { name, path, handle, parentHandle, category, reason }
        
        // Phase 2 State
        let csvDataStore = { A: null, B: null, C: null };
        let destHandles = { A: null, B: null, C: null };
        let sourceDirHandle2 = null;
        
        let isProcessing = false; // Global stop flag

        // --- UI Toggles ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        });
        if (localStorage.getItem('darkMode') === 'enabled') document.documentElement.classList.add('dark-mode');

        // Phase Switching
        document.getElementById('btnPhase1').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'block';
            document.getElementById('phase2-container').style.display = 'none';
            document.getElementById('btnPhase1').classList.add('active');
            document.getElementById('btnPhase2').classList.remove('active');
        });
        document.getElementById('btnPhase2').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
        });

        // --- Phase 1: Analysis Logic ---

        document.getElementById('selectSourceBtn').addEventListener('click', async () => {
            try {
                sourceDirHandle = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay').textContent = `Selected: ${sourceDirHandle.name}`;
                document.getElementById('analyzeBtn').disabled = false;
            } catch (err) { console.error(err); }
        });

        document.getElementById('analyzeBtn').addEventListener('click', async () => {
            if (!sourceDirHandle) return;
            
            const loading = document.getElementById('loading1');
            const txt = document.getElementById('loadingText1');
            const stopBtn = document.getElementById('stopAnalyzeBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            analyzeBtn.disabled = true; // Prevent double click
            isProcessing = true;
            
            allFiles = [];
            resetLists();
            
            try {
                txt.textContent = "Scanning folders...";
                // Get selected scan mode
                const mode = document.querySelector('input[name="scanMode"]:checked').value;
                
                const filesToProcess = await scanForPdfs(sourceDirHandle, '', 0, mode);
                
                let processed = 0;
                for (const file of filesToProcess) {
                    if (!isProcessing) {
                        txt.textContent = "Analysis Stopped.";
                        break;
                    }
                    
                    processed++;
                    txt.textContent = `Analyzing ${processed}/${filesToProcess.length}: ${file.name}`;
                    
                    const result = await analyzePdf(file);
                    allFiles.push(result);
                }

                displayResults();
            } catch (error) {
                alert("Error during analysis: " + error.message);
                console.error(error);
            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                analyzeBtn.disabled = false;
            }
        });
        
        document.getElementById('stopAnalyzeBtn').addEventListener('click', () => {
            isProcessing = false;
            document.getElementById('loadingText1').textContent = "Stopping...";
        });

        // Recursive Scan for KA*.pdf in subfolders
        async function scanForPdfs(dirHandle, path = '', depth = 0, mode = 'subfolders') {
            let results = [];
            const kaPattern = /^KA\d{8}.*\.pdf$/i;

            try {
                for await (const entry of dirHandle.values()) {
                    try {
                        if (entry.kind === 'directory') {
                            // Logic: Recurse if mode is 'subfolders' or 'both'.
                            // Also, if mode is 'root', we STOP at depth 0 (don't go deeper).
                            if (mode === 'root') continue;

                            // Go deeper - PASS entry as the new parentHandle for the recursive call logic
                            const subPath = path ? `${path}/${entry.name}` : entry.name;
                            const subResults = await scanForPdfs(entry, subPath, depth + 1, mode);
                            results = results.concat(subResults);
                        } else if (entry.kind === 'file') {
                            // Logic:
                            // If mode 'subfolders': Process only if depth > 0
                            // If mode 'root': Process only if depth == 0
                            // If mode 'both': Process all
                            
                            let shouldProcess = false;
                            if (mode === 'both') shouldProcess = true;
                            else if (mode === 'root' && depth === 0) shouldProcess = true;
                            else if (mode === 'subfolders' && depth > 0) shouldProcess = true;

                            if (!shouldProcess) continue;

                            // Check filename pattern
                            if (kaPattern.test(entry.name)) {
                                results.push({
                                    name: entry.name,
                                    handle: entry,
                                    parentHandle: dirHandle, // CRITICAL FIX: Use the current dirHandle context
                                    relativePath: path ? `${path}/${entry.name}` : entry.name
                                });
                            }
                        }
                    } catch (innerErr) {
                        console.warn(`Skipping entry ${entry.name} due to error:`, innerErr);
                    }
                }
            } catch (dirErr) {
                console.warn(`Error reading directory ${dirHandle.name}:`, dirErr);
            }
            return results;
        }

        // Core Analysis Logic
        async function analyzePdf(fileObj) {
            // Default Result
            const res = { ...fileObj, category: 'C', reason: 'Unknown' };

            try {
                // MOVED INSIDE TRY BLOCK: File Reading
                const fileData = await fileObj.handle.getFile();
                const arrayBuffer = await fileData.arrayBuffer();

                // 1. Load PDF
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                const pdf = await loadingTask.promise;

                // 2. Check Page 1 Header ("Annual Enterprise Survey")
                const page1 = await pdf.getPage(1);
                const textContent1 = await page1.getTextContent();
                const page1Text = textContent1.items.map(item => item.str).join(' ');
                
                if (!page1Text.toLowerCase().includes("annual enterprise survey")) {
                    return { ...res, category: 'A', reason: 'Not Survey Form' };
                }

                // 3. Check Encryption / Form Fields
                // PDF.js handles encryption automatically by throwing PasswordException usually, 
                // but we can check stats.
                // Simplified: If we got here, it's readable. Check for form fields.
                // Note: retrieving annotations from all pages to count fields
                let totalFields = 0;
                for (let i = 1; i <= pdf.numPages; i++) {
                    const p = await pdf.getPage(i);
                    const anns = await p.getAnnotations();
                    const widgets = anns.filter(a => a.subtype === 'Widget');
                    totalFields += widgets.length;
                }

                if (totalFields === 0) {
                    return { ...res, category: 'A', reason: 'No Form Fields' };
                }

                // --- NEW: Global Page 1 Lock Check (Robust Edge Case Filter) ---
                // Instead of finding one specific field, check if the majority of Page 1 fields are locked.
                
                const p1Anns = await page1.getAnnotations();
                // BROADENED CHECK: Check ALL Widgets, not just 'Tx' (Text)
                const p1Widgets = p1Anns.filter(a => a.subtype === 'Widget'); 
                
                if (p1Widgets.length > 0) {
                    let lockedCount = 0;
                    for (const w of p1Widgets) {
                        // Check if locked
                        if (w.readOnly || (w.fieldFlags & 1) === 1) {
                            lockedCount++;
                        }
                    }
                    
                    // Heuristic: If ANY single widget on Page 1 is locked, treat as Non-Editable.
                    if (lockedCount > 0) {
                         return { ...res, category: 'A', reason: `Non-Editable (Page 1 has ${lockedCount} locked fields)` };
                    }
                }

                // 4. Last Page Analysis ("Office use:" + Tickboxes)
                const lastPage = await pdf.getPage(pdf.numPages);
                
                // Get Text "Office use:" Position
                const lastPageText = await lastPage.getTextContent();
                const officeUseItem = lastPageText.items.find(item => 
                    item.str.toLowerCase().includes("office use") || 
                    item.str.toLowerCase().includes("office use:")
                );

                if (!officeUseItem) {
                    return { ...res, category: 'C', reason: 'Missing "Office use:" section' };
                }

                // PDF Coordinates: Origin (0,0) is usually Bottom-Left.
                // So "Below" text means Y < officeUseItem.transform[5]
                const textY = officeUseItem.transform[5]; 

                // Get Checkboxes
                const anns = await lastPage.getAnnotations();
                const checkboxes = anns.filter(a => 
                    a.subtype === 'Widget' && 
                    a.fieldType === 'Btn' && 
                    !a.radioButton // Button but not radio
                );

                // Filter spatially below the text
                // Note: annotation rect is [x1, y1, x2, y2]. y1/y2 depend on rotation, but generally smaller Y is lower on page.
                const relevantBoxes = checkboxes.filter(box => {
                    const boxY = box.rect[1]; // Bottom Y
                    return boxY < textY; // It is physically below the text header
                });

                if (relevantBoxes.length === 0) {
                    return { ...res, category: 'C', reason: 'No checkboxes in Office Use section' };
                }

                // Check Editability of these boxes
                let hasEditable = false;
                for (const box of relevantBoxes) {
                    // Bit 1 in FieldFlags = ReadOnly
                    const isReadOnly = box.readOnly || (box.fieldFlags & 1) === 1;
                    if (!isReadOnly) {
                        hasEditable = true;
                        break;
                    }
                }

                if (hasEditable) {
                    return { ...res, category: 'B', reason: 'Tickable Box Found' };
                } else {
                    return { ...res, category: 'C', reason: 'Boxes Locked' };
                }

            } catch (err) {
                if (err.name === 'PasswordException') {
                    return { ...res, category: 'A', reason: 'Encrypted' };
                }
                return { ...res, category: 'A', reason: 'Error: ' + err.message };
            }
        }

        // Display Functions
        function resetLists() {
            document.getElementById('listA').innerHTML = '';
            document.getElementById('listB').innerHTML = '';
            document.getElementById('listC').innerHTML = '';
            document.getElementById('resultsArea').style.display = 'none';
        }

        function displayResults() {
            document.getElementById('resultsArea').style.display = 'block';
            
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => groups[f.category].push(f));

            document.getElementById('countA').textContent = groups.A.length;
            document.getElementById('countB').textContent = groups.B.length;
            document.getElementById('countC').textContent = groups.C.length;

            renderList('listA', groups.A);
            renderList('listB', groups.B);
            renderList('listC', groups.C);
        }

        function renderList(id, files) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            files.forEach(f => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.title = "Click to open PDF in new tab"; // Hover Tooltip
                div.innerHTML = `
                    <span>${f.relativePath}</span>
                    <span class="reason-tag">${f.reason}</span>
                `;
                
                // Click to open
                div.addEventListener('click', async () => {
                    try {
                        const file = await f.handle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                        // Note: Revoke logic is tricky with open-in-new-tab, browser handles cleanup usually on close
                    } catch(e) {
                        alert("Could not open file: " + e.message);
                    }
                });

                container.appendChild(div);
            });
        }

        window.showTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`list${c}`).style.display = isMatch ? 'block' : 'none';
                // Show relevant download button
                document.getElementById(`downloadCsvBtn${c}`).style.display = isMatch ? 'inline-block' : 'none';
            });
            // Simple generic tab toggle
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        // CSV Export - Split into 3 functions
        function downloadCsvForCategory(cat) {
            const files = allFiles.filter(f => f.category === cat);
            if (files.length === 0) {
                alert(`No files in Category ${cat} to export.`);
                return;
            }
            
            let csv = "FilePath,FileName,Category,Reason,MoveStatus\n";
            files.forEach(f => {
                // Remove filename from path (get directory only)
                // relativePath is "Subfolder/File.pdf" -> "Subfolder"
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                const dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';

                const path = `"${dirPath}"`; // Directory Only
                const reason = `"${f.reason}"`;
                csv += `${path},${f.name},${f.category},${reason},Pending\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pdf-analysis-${cat}-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
            a.click();
        }

        document.getElementById('downloadCsvBtnA').addEventListener('click', () => downloadCsvForCategory('A'));
        document.getElementById('downloadCsvBtnB').addEventListener('click', () => downloadCsvForCategory('B'));
        document.getElementById('downloadCsvBtnC').addEventListener('click', () => downloadCsvForCategory('C'));

        document.getElementById('resetBtn1').addEventListener('click', () => {
            allFiles = [];
            resetLists();
            document.getElementById('sourcePathDisplay').textContent = 'No folder selected';
            sourceDirHandle = null;
            document.getElementById('analyzeBtn').disabled = true;
        });


        // --- Phase 2: Move Logic ---

        document.getElementById('selectSourceBtn2').addEventListener('click', async () => {
             try {
                sourceDirHandle2 = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name}`;
                
                // Enable CSV Inputs
                ['A', 'B', 'C'].forEach(cat => {
                    const lbl = document.getElementById(`lblCsv${cat}`);
                    const inp = document.getElementById(`csvInput${cat}`);
                    if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                    if(inp) { inp.disabled = false; }
                });

                checkMoveReady();
            } catch (err) { console.error(err); }
        });

        // CSV Inputs Handlers (A, B, C)
        ['A', 'B', 'C'].forEach(cat => {
            document.getElementById(`csvInput${cat}`).addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const text = await file.text();
                csvDataStore[cat] = parseCsv(text);
                document.getElementById(`csvDisplay${cat}`).textContent = `${file.name} (${csvDataStore[cat].length} rows)`;
                checkMoveReady();
            });
        });

        async function pickDest(cat) {
            try {
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' }); // Request write permission upfront
                destHandles[cat] = handle;
                document.getElementById(`pathDest${cat}`).textContent = handle.name;
                checkMoveReady();
            } catch(e) { console.error(e); }
        }

        document.getElementById('btnDestA').addEventListener('click', () => pickDest('A'));
        document.getElementById('btnDestB').addEventListener('click', () => pickDest('B'));
        document.getElementById('btnDestC').addEventListener('click', () => pickDest('C'));

        function checkMoveReady() {
            if (!sourceDirHandle2) {
                document.getElementById('executeMoveBtn').disabled = true;
                // Ensure buttons stay disabled if source not selected
                ['A', 'B', 'C'].forEach(c => {
                    document.getElementById(`btnDest${c}`).disabled = true;
                });
                return;
            }
            // Enable destination buttons if source is ready AND CSV is loaded for that row
            ['A', 'B', 'C'].forEach(c => {
                const hasCsv = !!csvDataStore[c];
                document.getElementById(`btnDest${c}`).disabled = !hasCsv; 
            });

            // Check if at least ONE row is fully ready (CSV + Folder)
            const readyA = csvDataStore.A && destHandles.A;
            const readyB = csvDataStore.B && destHandles.B;
            const readyC = csvDataStore.C && destHandles.C;

            document.getElementById('executeMoveBtn').disabled = !(readyA || readyB || readyC);
        }

        function parseCsv(text) {
            const lines = text.split('\n').filter(l => l.trim());
            // Simple check to see if header exists, assuming standard format
            const startIdx = lines[0].toLowerCase().startsWith('filepath') ? 1 : 0;
            
            // Improved Regex split to handle quoted fields
            const regex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
            
            const data = [];
            for(let i=startIdx; i<lines.length; i++) {
                const cols = lines[i].split(regex).map(s => s.replace(/^"|"$/g, '').trim());
                if(cols.length < 2) continue; // Need at least path and name
                data.push({
                    path: cols[0],
                    name: cols[1],
                    category: cols[2] || '' // Optional read, we use the row's explicit assignment
                });
            }
            return data;
        }

        document.getElementById('executeMoveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading2');
            const log = document.getElementById('moveLog');
            const generateSummary = document.getElementById('generateSummaryCheckbox').checked;
            const stopBtn = document.getElementById('stopMoveBtn');
            const execBtn = document.getElementById('executeMoveBtn');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            execBtn.disabled = true;
            log.style.display = 'block';
            log.innerHTML = '';
            isProcessing = true;
            
            const summaryData = []; // Store for CSV export

            try {
                // Iterate over categories A, B, C
                for (const cat of ['A', 'B', 'C']) {
                    if (!isProcessing) break; // Stop check outer loop
                    
                    const data = csvDataStore[cat];
                    const targetFolder = destHandles[cat];

                    // Skip if not configured (CSV missing or Folder missing)
                    if (!data || !targetFolder) continue;

                    for (const row of data) {
                        if (!isProcessing) {
                            logMsg("SYSTEM", "Process stopped by user", "orange");
                            break; // Stop check inner loop
                        }

                        const summaryRow = {
                            FileName: row.name,
                            OriginalPath: row.path,
                            Category: cat,
                            DestinationFolder: targetFolder.name,
                            Status: 'Pending',
                            Message: ''
                        };

                        // 1. Find File in Source
                        // CSV Row Path is "Subfolder" (Directory). Filename is separate.
                        let pathParts = row.path ? row.path.split('/') : [];
                        pathParts = pathParts.filter(p => p);
                        pathParts.push(row.name);

                        let currentHandle = sourceDirHandle2;
                        let fileHandle = null;
                        let parentHandle = sourceDirHandle2; 

                        try {
                            // Traverse
                            for(let i=0; i<pathParts.length; i++) {
                                const part = pathParts[i];
                                if (i === pathParts.length - 1) {
                                    fileHandle = await currentHandle.getFileHandle(part);
                                } else {
                                    currentHandle = await currentHandle.getDirectoryHandle(part);
                                    parentHandle = currentHandle;
                                }
                            }
                        } catch (e) {
                            logMsg(row.name, "File Not Found in Source", 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "File Not Found in Source";
                            summaryData.push(summaryRow);
                            continue;
                        }

                        // 2. Move
                        try {
                            const fileData = await fileHandle.getFile();
                            // Check collision
                            let newName = row.name;
                            try {
                                await targetFolder.getFileHandle(newName);
                                newName = newName.replace('.pdf', `_${Date.now()}.pdf`);
                            } catch(e) {}

                            const newFileHandle = await targetFolder.getFileHandle(newName, { create: true });
                            const writable = await newFileHandle.createWritable();
                            await writable.write(fileData);
                            await writable.close();

                            await parentHandle.removeEntry(fileHandle.name);

                            logMsg(row.name, `Moved to ${targetFolder.name}`, 'green');
                            summaryRow.Status = 'Success';
                            summaryRow.Message = `Moved to ${targetFolder.name}`;

                        } catch (e) {
                            logMsg(row.name, "Error Moving: " + e.message, 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "Error Moving: " + e.message;
                        }
                        
                        summaryData.push(summaryRow);
                    }
                }
                
                // Generate Summary CSV (Even if stopped)
                if (generateSummary && summaryData.length > 0) {
                     let csvContent = "FileName,OriginalPath,Category,DestinationFolder,Status,Message\n";
                     summaryData.forEach(row => {
                         const escape = (val) => `"${String(val).replace(/"/g, '""')}"`;
                         csvContent += `${escape(row.FileName)},${escape(row.OriginalPath)},${escape(row.Category)},${escape(row.DestinationFolder)},${escape(row.Status)},${escape(row.Message)}\n`;
                     });
                     
                     const blob = new Blob([csvContent], { type: 'text/csv' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = `move-summary-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
                     document.body.appendChild(a); 
                     a.click();
                     document.body.removeChild(a);
                }

            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                // We don't auto-enable execBtn because state might need reset or re-check, 
                // but usually it's safe to re-enable if they want to try again.
                execBtn.disabled = false; 
                checkMoveReady(); // Re-verify state
            }
        });
        
        document.getElementById('stopMoveBtn').addEventListener('click', () => {
            isProcessing = false;
            logMsg("SYSTEM", "Stopping... finishing current file...", "orange");
        });

        function logMsg(name, msg, color) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `<span>${name}</span><span style="color:${color}">${msg}</span>`;
            document.getElementById('moveLog').appendChild(div);
        }

        document.getElementById('resetBtn2').addEventListener('click', () => {
            // Reload page for full clean slate
            window.location.reload();
        });

    </script>
</body>
</html>
