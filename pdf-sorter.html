<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Sorter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        // Fix for standard font loading error
        pdfjsLib.GlobalWorkerOptions.standardFontDataUrl = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/';
    </script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <style>
        :root {
            --bg-primary: #f4f6f9;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #4b4b6a;
            --accent-primary: #6a5acd;
            --accent-secondary: #4a4a6a;
            --button-primary: #4CAF50;
            --button-secondary: #2196F3;
            --button-danger: #FF6B6B;
            --button-warning: #FF9800;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --bg-primary: #16213e;
            --bg-secondary: #0f3460;
            --text-primary: #e5e5e5;
            --text-secondary: #c0c0c0;
            --accent-primary: #6a5acd;
            --accent-secondary: #7b68ee;
            --button-primary: #388E3C;
            --button-secondary: #1976D2;
            --button-danger: #FF5252;
            --button-warning: #F57C00;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; transition: all 0.3s ease; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .toggle-icons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toggle-icons button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 100%;
            max-width: 900px;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-primary); }
        h3 { margin-bottom: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            color: white;
            font-size: 0.9rem;
        }
        
        .button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--button-primary); }
        .btn-secondary { background-color: var(--button-secondary); }
        .btn-danger { background-color: var(--button-danger); }
        .btn-warning { background-color: var(--button-warning); }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            word-break: break-all;
        }

        .results-section { display: none; }
        
        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .tab-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .file-list {
            height: 300px;
            overflow-y: auto;
            background: rgba(0,0,0,0.02);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            cursor: pointer; /* Visual cue */
        }
        
        .file-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .file-item:last-child { border-bottom: none; }
        .reason-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-secondary);
            color: white;
            margin-left: 10px;
        }

        .loading { display: none; text-align: center; margin: 20px; }
        
        .phase-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        .phase-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding-bottom: 5px;
        }

        .phase-btn.active {
            color: var(--accent-primary);
            border-bottom: 3px solid var(--accent-primary);
            font-weight: bold;
        }

        #phase2-container { display: none; }

        /* Special coloring for categories */
        .cat-a { color: var(--button-danger); } /* Non-Editable */
        .cat-b { color: var(--button-primary); } /* Tickable */
        .cat-c { color: var(--button-warning); } /* Locked/Other */

        /* Processing Time Display */
        .status-message {
            text-align: center;
            margin: 10px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="toggle-icons">
        <button id="darkModeToggle">ðŸŒ“</button>
    </div>

    <div class="container">
        <h1>PDF Form Sorter</h1>
        
        <div class="phase-selector">
            <button class="phase-btn active" id="btnPhase1">1. Analyze & Export</button>
            <button class="phase-btn" id="btnPhase2">2. Move via CSV</button>
        </div>

        <!-- Phase 1: Analyze -->
        <div id="phase1-container">
            <div class="button-container">
                <button id="selectSourceBtn" class="button btn-secondary">Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay" class="status-box">No folder selected</div>

            <div style="text-align:center; margin-bottom:15px;">
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="subfolders" checked> Scan Subfolders Only
                </label>
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="root"> Scan Root Only
                </label>
                <label style="cursor:pointer;">
                    <input type="radio" name="scanMode" value="both"> Scan Both
                </label>
            </div>

            <div class="button-container">
                <button id="analyzeBtn" class="button btn-primary" disabled>Analyze PDFs</button>
                <button id="stopAnalyzeBtn" class="button btn-warning" style="display:none;">Stop Analysis</button>
                <button id="resetBtn1" class="button btn-danger">Reset</button>
            </div>

            <div id="loading1" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Processing..." width="40">
                <p id="loadingText1">Scanning...</p>
            </div>

            <div id="resultsArea" class="results-section">
                <div class="tab-container">
                    <button class="tab-btn active" onclick="showTab('A')">Folder A (Non-Editable) <span id="countA">0</span></button>
                    <button class="tab-btn" onclick="showTab('B')">Folder B (Office Use: tickable) <span id="countB">0</span></button>
                    <button class="tab-btn" onclick="showTab('C')">Folder C (Office Use: not tickable) <span id="countC">0</span></button>
                </div>

                <div id="listA" class="file-list"></div>
                <div id="listB" class="file-list" style="display:none"></div>
                <div id="listC" class="file-list" style="display:none"></div>

                <div class="button-container">
                    <button id="downloadCsvBtnA" class="button btn-danger" style="display:none;">Download Category A CSV</button>
                    <button id="downloadCsvBtnB" class="button btn-primary" style="display:none;">Download Category B CSV</button>
                    <button id="downloadCsvBtnC" class="button btn-warning" style="display:none;">Download Category C CSV</button>
                </div>
            </div>
        </div>

        <!-- Phase 2: Move -->
        <div id="phase2-container">
            <p style="text-align:center; color:var(--text-secondary); margin-bottom:20px;">
                Upload CSVs for the categories you wish to process. You can process one, two, or all three.
            </p>

            <div class="button-container">
                <button id="selectSourceBtn2" class="button btn-secondary">1. Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay2" class="status-box">No source folder selected</div>

            <style>
                .move-row {
                    display: grid;
                    grid-template-columns: 0.8fr 2fr 1.5fr; /* Adjusted columns for better spacing */
                    gap: 20px;
                    align-items: start; /* Top alignment fixes button misalignment */
                    background: rgba(255,255,255,0.05);
                    padding: 25px;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    margin-bottom: 15px;
                }
                .move-row h3 {
                    margin: 0;
                    font-size: 1rem;
                    border: none;
                    text-align: left;
                }
                /* Flex column for vertical rhythm in each cell */
                .move-row > div {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                }
                .file-status { font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px; }
                .tick-options {
                    margin-top: 15px;
                    font-size: 0.85rem;
                    background: rgba(0,0,0,0.05);
                    padding: 10px;
                    border-radius: 6px;
                }
                .tick-options strong {
                    grid-column: 1 / -1; /* Span full width */
                    margin-bottom: 5px;
                    display: block;
                }
                .tick-options label {
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    cursor: pointer;
                    padding: 4px;
                    border-radius: 4px;
                }
                .tick-options label:hover {
                    background: rgba(0,0,0,0.05);
                }
                .copy-option {
                    margin-top: 5px;
                    font-size: 0.9rem;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    cursor: pointer;
                    opacity: 0.9;
                }

                /* Minimizing Styles */
                .move-row { transition: all 0.3s ease; }
                .move-row.collapsed {
                    grid-template-columns: 1fr; /* Single full-width column */
                    padding: 10px 25px;
                    gap: 0;
                }
                .move-row.collapsed > div:nth-child(2),
                .move-row.collapsed > div:nth-child(3) {
                    display: none;
                }
                .move-row.collapsed .copy-option {
                    display: none;
                }
                /* Improved Minimize Styles */
                .move-row-header {
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 4px;
                    margin-bottom: 5px;
                }
                .move-row-header:hover {
                    background-color: rgba(0,0,0,0.03);
                }
                .toggle-icon {
                    margin-right: 8px;
                    font-size: 0.8rem;
                    transition: transform 0.3s ease;
                    display: inline-block;
                    color: var(--text-secondary);
                }
                /* Rotate icon when collapsed (point right) */
                .move-row.collapsed .toggle-icon {
                    transform: rotate(-90deg);
                }
            </style>

            <div style="margin-top:20px;">
                <!-- Row A -->
                <div class="move-row" id="rowA">
                    <div>
                        <div class="move-row-header" onclick="toggleRow('rowA')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-a" style="border:none; margin:0;">Folder A<br><small>(Non-Editable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeA"> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvA" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (A)
                            <input type="file" id="csvInputA" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayA" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestA" class="button btn-danger" style="width:100%; font-size:0.8rem;" disabled>Select Folder A</button>
                        <div id="pathDestA" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row B -->
                <div class="move-row" id="rowB">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowB')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-b" style="border:none; margin:0;">Folder B<br><small>(Office Use: tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeB"> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvB" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (B)
                            <input type="file" id="csvInputB" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayB" class="file-status">No CSV loaded</div>
                        <div class="tick-options" style="display:flex; flex-wrap:wrap; align-items:center; gap:15px;">
                            <label style="font-weight:bold; color:var(--accent-primary); cursor:pointer; white-space:nowrap;">
                                <input type="checkbox" id="cbOverrideB"> Override PDF
                            </label>
                            <div id="containerTicksB" style="display:flex; gap:8px; opacity:0.5; pointer-events:none; align-items:center;">
                                <label><input type="checkbox" class="tick-opt-b" value="0"> adr</label>
                                <label><input type="checkbox" class="tick-opt-b" value="1"> brg</label>
                                <label><input type="checkbox" class="tick-opt-b" value="2"> cmp</label>
                                <label><input type="checkbox" class="tick-opt-b" value="3" checked> dta</label>
                                <label><input type="checkbox" class="tick-opt-b" value="4"> phn</label>
                                <label><input type="checkbox" class="tick-opt-b" value="5"> oth</label>
                            </div>
                        </div>
                    </div>
                    <div>
                        <button id="btnDestB" class="button btn-primary" style="width:100%; font-size:0.8rem;" disabled>Select Folder B</button>
                        <div id="pathDestB" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row C -->
                <div class="move-row" id="rowC">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowC')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-c" style="border:none; margin:0;">Folder C<br><small>(Office Use: not tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeC"> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (C)
                            <input type="file" id="csvInputC" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayC" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestC" class="button btn-warning" style="width:100%; font-size:0.8rem;" disabled>Select Folder C</button>
                        <div id="pathDestC" class="file-status">Not Selected</div>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                    <input type="checkbox" id="generateSummaryCheckbox" checked>
                    Generate Summary CSV Report
                </label>
            </div>

            <div class="button-container">
                <button id="executeMoveBtn" class="button btn-primary" disabled>Execute Move</button>
                <button id="stopMoveBtn" class="button btn-warning" style="display:none;">Stop Move</button>
                <button id="resetBtn2" class="button btn-danger">Reset</button>
            </div>

             <div id="loading2" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Moving..." width="40">
                <p id="loadingText2">Moving files...</p>
            </div>

            <div id="moveLog" class="file-list" style="display:none; height: 200px;"></div>
        </div>

        <div id="processingTimeContainer" class="container" style="display: none; margin-top: 20px;">
             <p id="processingTime" class="status-message">Total processing time: <span id="time"></span></p>
        </div>

    </div>

    <script>
        // --- State Management ---
        let sourceDirHandle = null;
        let allFiles = []; // { name, path, handle, parentHandle, category, reason }
        
        // Phase 2 State
        let csvDataStore = { A: null, B: null, C: null };
        let destHandles = { A: null, B: null, C: null };
        let sourceDirHandle2 = null;
        
        let isProcessing = false; // Global stop flag

        // --- UI Toggles ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        });
        if (localStorage.getItem('darkMode') === 'enabled') document.documentElement.classList.add('dark-mode');

        // Phase Switching
        document.getElementById('btnPhase1').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'block';
            document.getElementById('phase2-container').style.display = 'none';
            document.getElementById('btnPhase1').classList.add('active');
            document.getElementById('btnPhase2').classList.remove('active');
        });
        document.getElementById('btnPhase2').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
        });

        // --- Phase 1: Analysis Logic ---

        document.getElementById('selectSourceBtn').addEventListener('click', async () => {
            try {
                sourceDirHandle = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay').textContent = `Selected: ${sourceDirHandle.name}`;
                document.getElementById('analyzeBtn').disabled = false;
            } catch (err) { console.error(err); }
        });

        document.getElementById('analyzeBtn').addEventListener('click', async () => {
            if (!sourceDirHandle) return;
            
            const loading = document.getElementById('loading1');
            const txt = document.getElementById('loadingText1');
            const stopBtn = document.getElementById('stopAnalyzeBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const timeContainer = document.getElementById('processingTimeContainer');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            timeContainer.style.display = 'none';
            analyzeBtn.disabled = true; // Prevent double click
            isProcessing = true;
            
            allFiles = [];
            resetLists();
            
            const startTime = performance.now();

            try {
                txt.textContent = "Scanning folders...";
                // Get selected scan mode
                const mode = document.querySelector('input[name="scanMode"]:checked').value;
                
                const filesToProcess = await scanForPdfsConcurrent(sourceDirHandle, mode);
                
                let processedCount = 0;
                const total = filesToProcess.length;
                
                // Helper for Dynamic Concurrency Pool
                async function runConcurrentPool(items, limit, taskFn) {
                    const results = [];
                    const executing = new Set();
                    
                    let lastUpdate = 0;

                    for (const item of items) {
                        if (!isProcessing) break;

                        const p = taskFn(item).then(res => {
                            executing.delete(p);
                            processedCount++;
                            
                            // Throttle UI updates to every 100ms
                            const now = Date.now();
                            if (now - lastUpdate > 100) {
                                lastUpdate = now;
                                requestAnimationFrame(() => {
                                    txt.textContent = `Analyzing ${processedCount}/${total}`;
                                });
                            }
                            
                            return res;
                        });
                        
                        results.push(p);
                        executing.add(p);
                        
                        if (executing.size >= limit) {
                            await Promise.race(executing);
                        }
                    }
                    return Promise.all(results);
                }

                const CONCURRENCY_LIMIT = 8; // Active workers
                const results = await runConcurrentPool(filesToProcess, CONCURRENCY_LIMIT, analyzePdf);
                
                // Filter and store valid results
                results.forEach(r => {
                    if (r) allFiles.push(r);
                });

                displayResults();
                
                const endTime = performance.now();
                displayProcessingTime(startTime, endTime);

            } catch (error) {
                alert("Error during analysis: " + error.message);
                console.error(error);
            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                analyzeBtn.disabled = false;
            }
        });
        
        document.getElementById('stopAnalyzeBtn').addEventListener('click', () => {
            isProcessing = false;
            document.getElementById('loadingText1').textContent = "Stopping...";
        });

        // Concurrent Scan for KA*.pdf
        async function scanForPdfsConcurrent(dirHandle, mode = 'subfolders') {
            const results = [];
            const kaPattern = /^KA\d{8}.*\.pdf$/i;
            const queue = [{ handle: dirHandle, path: '', depth: 0 }];
            const MAX_CONCURRENT_DIRS = 8; // Chrome typically handles this well

            async function processDirectory(item) {
                const { handle, path, depth } = item;
                const subDirs = [];
                
                try {
                    for await (const entry of handle.values()) {
                         // Check stop flag
                        if (!isProcessing) return;

                        if (entry.kind === 'directory') {
                             // Logic: Recurse if mode is 'subfolders' or 'both'.
                            // Also, if mode is 'root', we STOP at depth 0.
                            if (mode !== 'root') {
                                 const subPath = path ? `${path}/${entry.name}` : entry.name;
                                 subDirs.push({ 
                                     handle: entry, 
                                     path: subPath, 
                                     depth: depth + 1 
                                 });
                            }
                        } else if (entry.kind === 'file') {
                            // Logic:
                            // If mode 'subfolders': Process only if depth > 0
                            // If mode 'root': Process only if depth == 0
                            // If mode 'both': Process all
                            let shouldProcess = false;
                            if (mode === 'both') shouldProcess = true;
                            else if (mode === 'root' && depth === 0) shouldProcess = true;
                            else if (mode === 'subfolders' && depth > 0) shouldProcess = true;

                            if (shouldProcess && kaPattern.test(entry.name)) {
                                results.push({
                                    name: entry.name,
                                    handle: entry,
                                    parentHandle: handle,
                                    relativePath: path ? `${path}/${entry.name}` : entry.name
                                });
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`Error reading ${handle.name}:`, e);
                }
                
                return subDirs;
            }

            while (queue.length > 0 && isProcessing) {
                const batch = queue.splice(0, MAX_CONCURRENT_DIRS);
                const batchResults = await Promise.all(batch.map(item => processDirectory(item)));
                
                // Add found subdirectories to queue
                batchResults.forEach(subDirs => {
                    if(subDirs) queue.push(...subDirs);
                });
            }

            return results;
        }

        function displayProcessingTime(startTime, endTime) {
            const totalTimeInSeconds = (endTime - startTime) / 1000;
            const hours = Math.floor(totalTimeInSeconds / 3600);
            const minutes = Math.floor((totalTimeInSeconds % 3600) / 60);
            const seconds = (totalTimeInSeconds % 60).toFixed(2);

            const timeSpan = document.getElementById('time');
            timeSpan.textContent = `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${seconds}s`;
            document.getElementById('processingTimeContainer').style.display = 'block';
        }

        // Core Analysis Logic
        async function analyzePdf(fileObj) {
            // 1. Start: Default to Category 'A' (Non-Editable)
            // This ensures that any error, missing fields, or locked status defaults here.
            const res = { ...fileObj, category: 'A', reason: 'Default / Error / Non-Editable' };
            let pdf = null;

            try {
                const fileData = await fileObj.handle.getFile();
                const arrayBuffer = await fileData.arrayBuffer();

                // Load PDF
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                pdf = await loadingTask.promise;

                // --- CHECK 1: Page 1 Analysis (Is it Editable?) ---
                const page1 = await pdf.getPage(1);
                
                // Optional: Check Header (to ensure it's the right form type)
                const textContent1 = await page1.getTextContent();
                const page1Text = textContent1.items.map(item => item.str).join(' ');
                if (!page1Text.toLowerCase().includes("annual enterprise survey")) {
                     return { ...res, reason: 'Non-Editable' }; // Retain A
                }

                const p1Anns = await page1.getAnnotations();
                const p1Widgets = p1Anns.filter(a => a.subtype === 'Widget');

                // If no widgets on Page 1 -> Not editable form -> Stay A
                if (p1Widgets.length === 0) {
                    return { ...res, reason: 'No Form Fields on Page 1' }; // Retain A
                }

                // Check for Locked Fields on Page 1
                let p1EditableCount = 0;
                for (const w of p1Widgets) {
                    // Check readOnly flag or FieldFlags bit 1 (ReadOnly)
                    const isLocked = w.readOnly || (w.fieldFlags & 1) === 1;
                    if (!isLocked) {
                        p1EditableCount++;
                    }
                }

                // If NO field on Page 1 is editable -> Treat as Non-Editable -> Stay A
                // This allows forms with mixed locked/unlocked fields (like pre-filled ID) to pass.
                if (p1EditableCount === 0) {
                    return { ...res, reason: `Non-Editable (Page 1 has 0 editable fields)` }; // Retain A
                }

                // --- If we are here, Page 1 is Clean & Editable ---
                // Now we determine if it goes to B or C based on "Office Use" section.

                // --- CHECK 2: Office Use Section (Last Page) ---
                const lastPage = await pdf.getPage(pdf.numPages);
                const lastPageText = await lastPage.getTextContent();
                
                // Find "Office use" text
                const officeUseItem = lastPageText.items.find(item => 
                    item.str.toLowerCase().includes("office use") || 
                    item.str.toLowerCase().includes("office use:")
                );

                if (!officeUseItem) {
                    // If Office Use section is missing completely -> Treat as "Widgets Missing" -> Stay A
                    // (Or arguably C, but plan says 'Widgets missing -> Do nothing (Retain A)')
                    return { ...res, reason: 'Missing "Office use:" section' }; // Retain A
                }

                const textY = officeUseItem.transform[5]; 
                const anns = await lastPage.getAnnotations();
                
                // Find checkboxes physically below the "Office use" text
                // We use a loose threshold (+20) to handle minor alignment issues, 
                // but STRICTLY exclude boxes significantly higher up (user boxes).
                const relevantBoxes = anns.filter(a => 
                    a.subtype === 'Widget' && 
                    a.fieldType === 'Btn' && 
                    !a.radioButton &&
                    a.rect[1] < (textY + 20) // Must be below or just inline with the text
                );

                if (relevantBoxes.length === 0) {
                    // If text is found but no boxes in the office section, it's effectively "Not Tickable" -> C
                    return { ...res, category: 'C', reason: 'No checkboxes found in Office Use section' }; 
                }

                // Check if these specific OFFICE boxes are Editable
                let hasEditableOfficeBox = false;
                for (const box of relevantBoxes) {
                    const isReadOnly = box.readOnly || (box.fieldFlags & 1) === 1;
                    if (!isReadOnly) {
                        hasEditableOfficeBox = true;
                        break;
                    }
                }

                // --- FINAL OUTCOME ---
                if (hasEditableOfficeBox) {
                    // Page 1 Editable AND Office Use Tickable -> Folder B
                    return { ...res, category: 'B', reason: 'Page 1 Editable & Office Use Tickable' };
                } else {
                    // Page 1 Editable BUT Office Use Locked -> Folder C
                    return { ...res, category: 'C', reason: 'Page 1 Editable but Office Use Locked' };
                }

            } catch (err) {
                // Any error -> Stay A
                if (err.name === 'PasswordException') {
                    return { ...res, reason: 'Encrypted / Password Protected' };
                }
                return { ...res, reason: 'Error: ' + err.message };
            } finally {
                // CRITICAL MEMORY CLEANUP
                if (pdf) {
                    await pdf.destroy();
                }
            }
        }

        // Display Functions
        function resetLists() {
            document.getElementById('listA').innerHTML = '';
            document.getElementById('listB').innerHTML = '';
            document.getElementById('listC').innerHTML = '';
            document.getElementById('resultsArea').style.display = 'none';
        }

        function displayResults() {
            document.getElementById('resultsArea').style.display = 'block';
            
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => groups[f.category].push(f));

            document.getElementById('countA').textContent = groups.A.length;
            document.getElementById('countB').textContent = groups.B.length;
            document.getElementById('countC').textContent = groups.C.length;

            renderList('listA', groups.A);
            renderList('listB', groups.B);
            renderList('listC', groups.C);
        }

        function renderList(id, files) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            files.forEach(f => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.title = "Ctrl+Click to open PDF in new tab"; // Hover Tooltip
                div.innerHTML = `
                    <span>${f.relativePath}</span>
                    <span class="reason-tag">${f.reason}</span>
                `;
                
                // Click to open
                div.addEventListener('click', async (e) => {
                    if (!e.ctrlKey && !e.metaKey) return; // specific user request
                    try {
                        const file = await f.handle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                        // Note: Revoke logic is tricky with open-in-new-tab, browser handles cleanup usually on close
                    } catch(e) {
                        alert("Could not open file: " + e.message);
                    }
                });

                container.appendChild(div);
            });
        }

        window.showTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`list${c}`).style.display = isMatch ? 'block' : 'none';
                // Show relevant download button
                document.getElementById(`downloadCsvBtn${c}`).style.display = isMatch ? 'inline-block' : 'none';
            });
            // Simple generic tab toggle
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        // CSV Export - Split into 3 functions
        function downloadCsvForCategory(cat) {
            const files = allFiles.filter(f => f.category === cat);
            if (files.length === 0) {
                alert(`No files in Category ${cat} to export.`);
                return;
            }
            
            let csv = "FilePath,FileName,Category,Reason,MoveStatus\n";
            files.forEach(f => {
                // Remove filename from path (get directory only)
                // relativePath is "Subfolder/File.pdf" -> "Subfolder"
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                let dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';

                // Prepend the root folder name to give context
                if (sourceDirHandle) {
                    dirPath = dirPath ? `${sourceDirHandle.name}/${dirPath}` : sourceDirHandle.name;
                }
                // Cleanup any trailing slashes if logic above left them (e.g. "Root/")
                if (dirPath.endsWith('/')) dirPath = dirPath.slice(0, -1);

                const path = `"${dirPath}"`; // Directory Only
                const reason = `"${f.reason}"`;
                csv += `${path},${f.name},${f.category},${reason},Pending\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pdf-analysis-${cat}-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
            a.click();
        }

        document.getElementById('downloadCsvBtnA').addEventListener('click', () => downloadCsvForCategory('A'));
        document.getElementById('downloadCsvBtnB').addEventListener('click', () => downloadCsvForCategory('B'));
        document.getElementById('downloadCsvBtnC').addEventListener('click', () => downloadCsvForCategory('C'));

        document.getElementById('resetBtn1').addEventListener('click', () => {
            allFiles = [];
            resetLists();
            document.getElementById('sourcePathDisplay').textContent = 'No folder selected';
            sourceDirHandle = null;
            document.getElementById('analyzeBtn').disabled = true;
        });


        // --- Phase 2: Move Logic ---

        document.getElementById('selectSourceBtn2').addEventListener('click', async () => {
             try {
                sourceDirHandle2 = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name}`;
                
                // Enable CSV Inputs
                ['A', 'B', 'C'].forEach(cat => {
                    const lbl = document.getElementById(`lblCsv${cat}`);
                    const inp = document.getElementById(`csvInput${cat}`);
                    if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                    if(inp) { inp.disabled = false; }
                });

                checkMoveReady();
            } catch (err) { console.error(err); }
        });

        // CSV Inputs Handlers (A, B, C)
        ['A', 'B', 'C'].forEach(cat => {
            document.getElementById(`csvInput${cat}`).addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const text = await file.text();
                csvDataStore[cat] = parseCsv(text);
                document.getElementById(`csvDisplay${cat}`).textContent = `${file.name} (${csvDataStore[cat].length} rows)`;
                checkMoveReady();
            });
        });

        async function pickDest(cat) {
            try {
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' }); // Request write permission upfront
                destHandles[cat] = handle;
                document.getElementById(`pathDest${cat}`).textContent = handle.name;
                checkMoveReady();
            } catch(e) { console.error(e); }
        }

        document.getElementById('btnDestA').addEventListener('click', () => pickDest('A'));
        document.getElementById('btnDestB').addEventListener('click', () => pickDest('B'));
        document.getElementById('btnDestC').addEventListener('click', () => pickDest('C'));

        // Override Checkbox Toggle
        document.getElementById('cbOverrideB').addEventListener('change', (e) => {
            const container = document.getElementById('containerTicksB');
            if (e.target.checked) {
                container.style.opacity = '1';
                container.style.pointerEvents = 'auto';
            } else {
                container.style.opacity = '0.5';
                container.style.pointerEvents = 'none';
            }
        });

        function checkMoveReady() {
            if (!sourceDirHandle2) {
                document.getElementById('executeMoveBtn').disabled = true;
                // Ensure buttons stay disabled if source not selected
                ['A', 'B', 'C'].forEach(c => {
                    document.getElementById(`btnDest${c}`).disabled = true;
                });
                return;
            }
            // Enable destination buttons if source is ready AND CSV is loaded for that row
            ['A', 'B', 'C'].forEach(c => {
                const hasCsv = !!csvDataStore[c];
                document.getElementById(`btnDest${c}`).disabled = !hasCsv; 
            });

            // Check if at least ONE row is fully ready (CSV + Folder)
            const readyA = csvDataStore.A && destHandles.A;
            const readyB = csvDataStore.B && destHandles.B;
            const readyC = csvDataStore.C && destHandles.C;

            document.getElementById('executeMoveBtn').disabled = !(readyA || readyB || readyC);
        }

        function parseCsv(text) {
            const lines = text.split('\n').filter(l => l.trim());
            // Simple check to see if header exists, assuming standard format
            const startIdx = lines[0].toLowerCase().startsWith('filepath') ? 1 : 0;
            
            // Improved Regex split to handle quoted fields
            const regex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
            
            const data = [];
            for(let i=startIdx; i<lines.length; i++) {
                const cols = lines[i].split(regex).map(s => s.replace(/^"|"$/g, '').trim());
                if(cols.length < 2) continue; // Need at least path and name
                data.push({
                    path: cols[0],
                    name: cols[1],
                    category: cols[2] || '' // Optional read, we use the row's explicit assignment
                });
            }
            return data;
        }

        document.getElementById('executeMoveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading2');
            const log = document.getElementById('moveLog');
            const generateSummary = document.getElementById('generateSummaryCheckbox').checked;
            const stopBtn = document.getElementById('stopMoveBtn');
            const execBtn = document.getElementById('executeMoveBtn');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            execBtn.disabled = true;
            log.style.display = 'block';
            log.innerHTML = '';
            isProcessing = true;
            const loadingText2 = document.getElementById('loadingText2');
            loadingText2.textContent = "Starting..."; // Reset default text
            
            const summaryData = []; // Store for CSV export

            try {
                // Iterate over categories A, B, C
                for (const cat of ['A', 'B', 'C']) {
                    if (!isProcessing) break; // Stop check outer loop
                    
                    const data = csvDataStore[cat];
                    const targetFolder = destHandles[cat];
                    const isCopyOnly = document.getElementById(`copyMode${cat}`).checked;

                    // Skip if not configured (CSV missing or Folder missing)
                    if (!data || !targetFolder) continue;

                    // Get selected tick indices for Category B
                    let selectedTickIndices = [];
                    if (cat === 'B') {
                        const opts = document.querySelectorAll('.tick-opt-b:checked');
                        opts.forEach(opt => selectedTickIndices.push(parseInt(opt.value)));
                    }

                    for (const row of data) {
                        if (!isProcessing) {
                            logMsg("SYSTEM", "Process stopped by user", "orange");
                            break; // Stop check inner loop
                        }

                        const action = isCopyOnly ? "Copying" : "Moving";
                        loadingText2.textContent = `${action} ${row.name}...`;

                        const summaryRow = {
                            FileName: row.name,
                            OriginalPath: row.path,
                            Category: cat,
                            DestinationFolder: targetFolder.name,
                            Status: 'Pending',
                            Message: ''
                        };

                        // 1. Find File in Source
                        // CSV Row Path is "Subfolder" (Directory). Filename is separate.
                        let rawPath = row.path || '';
                        // Remove quotes just in case
                        rawPath = rawPath.replace(/^"|"$/g, '');
                        let pathParts = rawPath.split('/').filter(p => p);

                        // FIX: If the CSV includes the root folder name (which we added), remove it
                        // so we don't look for Root inside Root.
                        if (pathParts.length > 0 && pathParts[0] === sourceDirHandle2.name) {
                            pathParts.shift();
                        }
                        
                        pathParts.push(row.name);

                        let currentHandle = sourceDirHandle2;
                        let fileHandle = null;
                        let parentHandle = sourceDirHandle2; 

                        try {
                            // Traverse
                            for(let i=0; i<pathParts.length; i++) {
                                const part = pathParts[i];
                                if (i === pathParts.length - 1) {
                                    fileHandle = await currentHandle.getFileHandle(part);
                                } else {
                                    currentHandle = await currentHandle.getDirectoryHandle(part);
                                    parentHandle = currentHandle;
                                }
                            }
                        } catch (e) {
                            logMsg(row.name, "File Not Found in Source", 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "File Not Found in Source";
                            summaryData.push(summaryRow);
                            continue;
                        }

                        // 2. Move
                        try {
                            let fileData = await fileHandle.getFile();
                            let fileArrayBuffer = await fileData.arrayBuffer();
                            
                            // === AUTOMATED MODIFICATION FOR CATEGORY B ===
                            const shouldOverride = document.getElementById('cbOverrideB').checked;
                            if (cat === 'B' && shouldOverride) {
                                try {
                                    // Load with pdf-lib
                                    const pdfDoc = await PDFLib.PDFDocument.load(fileArrayBuffer);
                                    const form = pdfDoc.getForm();
                                    const fields = form.getFields();
                                    const pageCount = pdfDoc.getPageCount();

                                    // We need to find the widgets on the LAST page to sort them spatially.
                                    // PDF-Lib fields reference widgets (refs). We need to resolve them to find their page/rect.
                                    // Simplified strategy: Get all checkbox fields, check if they belong to the last page,
                                    // and sort them by coordinate (Bottom-Up, Left-Right).
                                    
                                    const checkboxes = fields.filter(f => f instanceof PDFLib.PDFCheckBox);
                                    const relevantBoxes = [];

                                    for (const box of checkboxes) {
                                        const widgets = box.acroField.getWidgets();
                                        // A field can have multiple widgets, but usually 1 for these forms.
                                        for (const w of widgets) {
                                            const pRef = w.P();
                                            // This is low-level. Easier way: 
                                            // We assume the Office Use boxes are at the BOTTOM of the LAST page.
                                            // Let's get their coordinates.
                                            const rect = w.getRectangle();
                                            // Check if this widget is on the last page? 
                                            // PDF-Lib doesn't easily map field->page index without traversing pages.
                                            // So we traverse the last page's annotations instead.
                                        }
                                    }
                                    
                                    // BETTER STRATEGY: Top-Down Traversal (Page -> Annotations -> Fields)
                                    const lastPage = pdfDoc.getPage(pageCount - 1);
                                    const lastPageAnnots = lastPage.node.Annots(); // Returns PDFArray or undefined
                                    const candidates = [];

                                    if (lastPageAnnots) {
                                        // Create a map of Ref -> Field for all checkboxes to handle indirections
                                        const refToFieldMap = new Map();
                                        
                                        // Helper to map field refs
                                        for (const field of checkboxes) {
                                            // Key can be the Field Ref itself
                                            if (field.ref) refToFieldMap.set(field.ref.toString(), field);
                                            
                                            // Or the Widget Ref if it's separate
                                            const widgets = field.acroField.getWidgets();
                                            widgets.forEach(w => {
                                                if (w.ref) refToFieldMap.set(w.ref.toString(), field);
                                            });
                                        }

                                        // Traverse the page's annotations
                                        for (let i = 0; i < lastPageAnnots.size(); i++) {
                                            const annotRef = lastPageAnnots.get(i); // This might be a Ref or a Direct Dict
                                            let annotDict = null;
                                            let annotStr = null;

                                            if (annotRef instanceof PDFLib.PDFRef) {
                                                annotStr = annotRef.toString();
                                                annotDict = pdfDoc.context.lookup(annotRef);
                                            } else if (annotRef instanceof PDFLib.PDFDict) {
                                                annotDict = annotRef; // Direct object
                                            }

                                            if (!annotDict) continue;

                                            // Check if it is a Widget
                                            const subtype = annotDict.get(PDFLib.PDFName.of('Subtype'));
                                            if (subtype !== PDFLib.PDFName.of('Widget')) continue;

                                            // Try to find the linked Field
                                            let matchedField = null;
                                            
                                            // Strategy A: Ref match (if indirect)
                                            if (annotStr && refToFieldMap.has(annotStr)) {
                                                matchedField = refToFieldMap.get(annotStr);
                                            }
                                            
                                            // Strategy B: Parent lookup (if Widget is child of Field)
                                            if (!matchedField) {
                                                const parent = annotDict.get(PDFLib.PDFName.of('Parent'));
                                                if (parent instanceof PDFLib.PDFRef && refToFieldMap.has(parent.toString())) {
                                                    matchedField = refToFieldMap.get(parent.toString());
                                                }
                                            }

                                            // If found and it's a Checkbox, save it
                                            if (matchedField && matchedField instanceof PDFLib.PDFCheckBox) {
                                                const rectArr = annotDict.get(PDFLib.PDFName.of('Rect'));
                                                if (rectArr && rectArr instanceof PDFLib.PDFArray) {
                                                    const x = rectArr.get(0).asNumber();
                                                    const y = rectArr.get(1).asNumber();
                                                    candidates.push({ field: matchedField, x, y });
                                                }
                                            }
                                        }
                                    }

                                    // Sort: Primary Y (Ascending/Bottom-up? No, PDF coords Y=0 is bottom), Secondary X (Left-Right)
                                    // We want the group with the LOWEST Y (closest to bottom).
                                    // Group them by Y with some tolerance (e.g. 5 points)
                                    candidates.sort((a, b) => {
                                        const yDiff = Math.abs(a.y - b.y);
                                        if (yDiff < 10) return a.x - b.x; // Same row, sort Left-Right
                                        return a.y - b.y; // Different row, sort Bottom-Up (Lowest Y first)
                                    });
                                    
                                    // The Office Use section is at the bottom, so it should be the FIRST group in this sort (Lowest Y).
                                    // We expect 6 boxes: adr, brg, cmp, dta, phn, oth.
                                    // Indices: 0=adr, 1=brg, 2=cmp, 3=dta, 4=phn, 5=oth.
                                    
                                    if (candidates.length >= 6) { // Expect at least 6 for a full row
                                        // Check if the first 6 form a consistent row (similar Y)
                                        // We check if index 5 (last of the 6) is aligned with index 0.
                                        if (Math.abs(candidates[5].y - candidates[0].y) < 20) {
                                            let tickedCount = 0;
                                            let untickedCount = 0;
                                            
                                            // Enforce state for ALL 6 boxes based on selection
                                            for (let i = 0; i < 6; i++) {
                                                if (candidates[i]) {
                                                    if (selectedTickIndices.includes(i)) {
                                                        candidates[i].field.check();
                                                        tickedCount++;
                                                    } else {
                                                        candidates[i].field.uncheck();
                                                        untickedCount++;
                                                    }
                                                }
                                            }
                                            
                                            if (tickedCount > 0 || untickedCount > 0) {
                                                fileArrayBuffer = await pdfDoc.save(); // Update buffer to write
                                                summaryRow.Message += ` [Updated: ${tickedCount} Checked, ${untickedCount} Unchecked]`;
                                            }
                                        } else {
                                            summaryRow.Message += " [Warning: Layout mismatch (not a single row), no boxes modified]";
                                        }
                                    } else {
                                        summaryRow.Message += ` [Warning: Found only ${candidates.length} checkboxes, expected 6+. No boxes ticked]`;
                                    }
                                    
                                } catch (pdfLibErr) {
                                    console.error(pdfLibErr);
                                    summaryRow.Message += ` [Error Ticking: ${pdfLibErr.message}]`;
                                }
                            }
                            // =============================================

                            // Check collision
                            let newName = row.name;
                            try {
                                await targetFolder.getFileHandle(newName);
                                newName = newName.replace('.pdf', `_${Date.now()}.pdf`);
                            } catch(e) {}

                            const newFileHandle = await targetFolder.getFileHandle(newName, { create: true });
                            const writable = await newFileHandle.createWritable();
                            // Write the (potentially modified) buffer
                            await writable.write(fileArrayBuffer);
                            await writable.close();

                            if (!isCopyOnly) {
                                await parentHandle.removeEntry(fileHandle.name);
                                logMsg(row.name, `Moved to ${targetFolder.name}`, 'green');
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Moved]`;
                            } else {
                                logMsg(row.name, `Copied to ${targetFolder.name}`, 'blue');
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Copied]`;
                            }

                        } catch (e) {
                            logMsg(row.name, "Error Moving: " + e.message, 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "Error Moving: " + e.message;
                        }
                        
                        summaryData.push(summaryRow);
                    }
                }
                
                // Generate Summary CSV (Even if stopped)
                if (generateSummary && summaryData.length > 0) {
                     let csvContent = "FileName,OriginalPath,Category,DestinationFolder,Status,Message\n";
                     summaryData.forEach(row => {
                         const escape = (val) => `"${String(val).replace(/"/g, '""')}"`;
                         csvContent += `${escape(row.FileName)},${escape(row.OriginalPath)},${escape(row.Category)},${escape(row.DestinationFolder)},${escape(row.Status)},${escape(row.Message)}\n`;
                     });
                     
                     const blob = new Blob([csvContent], { type: 'text/csv' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = `move-summary-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
                     document.body.appendChild(a); 
                     a.click();
                     document.body.removeChild(a);
                }

            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                // We don't auto-enable execBtn because state might need reset or re-check, 
                // but usually it's safe to re-enable if they want to try again.
                execBtn.disabled = false; 
                checkMoveReady(); // Re-verify state
            }
        });
        
        document.getElementById('stopMoveBtn').addEventListener('click', () => {
            isProcessing = false;
            logMsg("SYSTEM", "Stopping... finishing current file...", "orange");
        });

        function logMsg(name, msg, color) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `<span>${name}</span><span style="color:${color}">${msg}</span>`;
            document.getElementById('moveLog').appendChild(div);
        }

        document.getElementById('resetBtn2').addEventListener('click', () => {
            // Reload page for full clean slate
            window.location.reload();
        });

        window.toggleRow = function(rowId) {
            const row = document.getElementById(rowId);
            row.classList.toggle('collapsed');
        };
    </script>
</body>
</html>
