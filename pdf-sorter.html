<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Sorter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        // Fix for standard font loading error
        pdfjsLib.GlobalWorkerOptions.standardFontDataUrl = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/';
    </script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <style>
        :root {
            --bg-primary: #f4f6f9;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #4b4b6a;
            --accent-primary: #6a5acd;
            --accent-secondary: #4a4a6a;
            --button-primary: #4CAF50;
            --button-secondary: #2196F3;
            --button-danger: #FF6B6B;
            --button-warning: #FF9800;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --bg-primary: #16213e;
            --bg-secondary: #0f3460;
            --text-primary: #e5e5e5;
            --text-secondary: #c0c0c0;
            --accent-primary: #6a5acd;
            --accent-secondary: #7b68ee;
            --button-primary: #388E3C;
            --button-secondary: #1976D2;
            --button-danger: #FF5252;
            --button-warning: #F57C00;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; transition: all 0.3s ease; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .toggle-icons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toggle-icons button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 100%;
            max-width: 900px;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-primary); }
        h3 { margin-bottom: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            color: white;
            font-size: 0.9rem;
        }
        
        .button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--button-primary); }
        .btn-secondary { background-color: var(--button-secondary); }
        .btn-danger { background-color: var(--button-danger); }
        .btn-warning { background-color: var(--button-warning); }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            word-break: break-all;
        }

        .results-section { display: none; }
        
        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .tab-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .file-list {
            height: 300px;
            overflow-y: auto;
            background: rgba(0,0,0,0.02);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            resize: vertical; /* Allow vertical resizing */
            min-height: 150px;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            cursor: pointer; /* Visual cue */
        }
        
        .file-item:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .file-item.visited {
            background-color: rgba(106, 90, 205, 0.1); /* Subtle purple highlight */
            border-left: 3px solid var(--accent-primary);
        }
        
        .file-item:last-child { border-bottom: none; }
        .reason-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-secondary);
            color: white;
            margin-left: 10px;
        }

        .loading { display: none; text-align: center; margin: 20px; }
        
        .phase-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        .phase-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding-bottom: 5px;
        }

        .phase-btn.active {
            color: var(--accent-primary);
            border-bottom: 3px solid var(--accent-primary);
            font-weight: bold;
        }

        #phase2-container { display: none; }

        /* Special coloring for categories */
        .cat-a { color: var(--button-danger); } /* Non-Editable */
        .cat-b { color: var(--button-primary); } /* Tickable */
        .cat-c { color: var(--button-warning); } /* Locked/Other */

        /* Processing Time Display */
        .status-message {
            text-align: center;
            margin: 10px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="toggle-icons">
        <button id="darkModeToggle">ðŸŒ“</button>
    </div>

    <div class="container">
        <h1>PDF Form Sorter</h1>
        
        <div class="phase-selector">
            <button class="phase-btn active" id="btnPhase1">1. Analyse & Export</button>
            <button class="phase-btn" id="btnPhase2">2. Move via CSV</button>
        </div>

        <!-- Phase 1: Analyse -->
        <div id="phase1-container">
            <div class="button-container">
                <button id="selectSourceBtn" class="button btn-secondary">Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay" class="status-box">No folder selected</div>

            <div style="text-align:center; margin-bottom:15px;">
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="subfolders" checked> Scan Subfolders Only
                </label>
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="root"> Scan Root Only
                </label>
                <label style="cursor:pointer;">
                    <input type="radio" name="scanMode" value="both"> Scan Both
                </label>
            </div>

            <div class="button-container">
                <button id="analyseBtn" class="button btn-primary" disabled>Analyse PDFs</button>
                <button id="stopAnalyseBtn" class="button btn-warning" style="display:none;">Stop Analysis</button>
                <button id="resetBtn1" class="button btn-danger">Reset</button>
            </div>

            <div id="loading1" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Processing..." width="40">
                <p id="loadingText1">Scanning...</p>
            </div>

            <div id="resultsArea" class="results-section">
                <div class="tab-container">
                    <button id="tabBtnA" class="tab-btn active" onclick="showTab('A')">Folder A (Non-Editable) <span id="countA">0</span></button>
                    <button id="tabBtnB" class="tab-btn" onclick="showTab('B')">Folder B (Office Use: tickable) <span id="countB">0</span></button>
                    <button id="tabBtnC" class="tab-btn" onclick="showTab('C')">Folder C (Office Use: not tickable) <span id="countC">0</span></button>
                </div>

                <div id="listA" class="file-list"></div>
                <div id="listB" class="file-list" style="display:none"></div>
                <div id="listC" class="file-list" style="display:none"></div>

                <div class="button-container">
                    <button id="downloadCsvBtnA" class="button btn-danger" style="display:none;">Download Category A CSV</button>
                    <button id="downloadCsvBtnB" class="button btn-primary" style="display:none;">Download Category B CSV</button>
                    <button id="downloadCsvBtnC" class="button btn-warning" style="display:none;">Download Category C CSV</button>
                </div>
            </div>
        </div>

        <!-- Phase 2: Move -->
        <div id="phase2-container">
            <p style="text-align:center; color:var(--text-secondary); margin-bottom:20px;">
                Upload CSVs for the categories you wish to process. You can process one, two, or all three.
            </p>

            <div class="button-container">
                <button id="selectSourceBtn2" class="button btn-secondary">1. Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay2" class="status-box">No source folder selected</div>

            <style>
                .move-row {
                    display: grid;
                    grid-template-columns: 1fr 1fr 1fr; /* Equal columns = Identical Buttons */
                    gap: 20px;
                    align-items: start; 
                    background: rgba(255,255,255,0.05);
                    padding: 25px;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    margin-bottom: 15px;
                }
                
                /* Style for the separated tick container to merge with Row B */
                .tick-row-full {
                    background: rgba(255,255,255,0.05);
                    border: 1px solid var(--border-color);
                    border-top: none; /* Visually merge with top row */
                    border-radius: 0 0 8px 8px;
                    padding: 15px 25px;
                    margin-bottom: 15px;
                    margin-top: -15px; /* Pull up to connect */
                    width: 100%;
                    box-sizing: border-box;
                }
                
                /* Special handling for Row B to connect to ticks */
                #rowB {
                    margin-bottom: 0;
                    border-radius: 8px 8px 0 0;
                    border-bottom: none; 
                }
                
                /* Hide tick row when parent is collapsed */
                #rowB.collapsed + .tick-row-full {
                    display: none;
                }

                /* UNIFORM BUTTON SIZING */
                #lblCsvA, #lblCsvB, #lblCsvC {
                    width: 100%;
                    display: block;
                    box-sizing: border-box;
                    text-align: center;
                    margin: 0;
                    min-width: 0;
                }
                .move-row h3 {
                    margin: 0;
                    font-size: 1rem;
                    border: none;
                    text-align: left;
                }
                /* Flex column for vertical rhythm in each cell */
                .move-row > div {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                }
                .file-status { font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px; }
                .tick-options {
                    margin-top: 15px;
                    font-size: 0.85rem;
                    background: rgba(0,0,0,0.05);
                    padding: 10px;
                    border-radius: 6px;
                    width: 100%; /* Ensure full width */
                    box-sizing: border-box;
                }
                .tick-options strong {
                    grid-column: 1 / -1; /* Span full width */
                    margin-bottom: 5px;
                    display: block;
                }
                .tick-options label {
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    cursor: pointer;
                    padding: 4px;
                    border-radius: 4px;
                }
                .tick-options label:hover {
                    background: rgba(0,0,0,0.05);
                }
                
                /* Force Tick Option Labels to grow */
                #containerTicksB {
                    display: flex;
                    width: 100%;
                    gap: 10px;
                    margin-top: 10px;
                }

                #containerTicksB label {
                    flex: 1 0 0;           /* Grow equally, ignore content size */
                    width: 100%;           /* Ensure it tries to fill */
                    display: flex;
                    justify-content: center; 
                    align-items: center;
                    border: 1px solid rgba(0,0,0,0.1); 
                    padding: 10px 5px;
                    border-radius: 4px;
                    text-align: center;
                    background: rgba(255,255,255,0.5);
                    white-space: nowrap;
                    cursor: pointer;
                    font-weight: bold;
                }

                /* Remove margin-top from separated container ticks to fit nicely */
                .tick-row-full .tick-options {
                    margin-top: 0;
                    background: transparent; /* Let parent background show */
                    padding: 0;
                }

                .copy-option {
                    margin-top: 5px;
                    font-size: 0.9rem;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    cursor: pointer;
                    opacity: 0.9;
                }

                /* Minimizing Styles */
                .move-row { transition: all 0.3s ease; }
                .move-row.collapsed {
                    grid-template-columns: 1fr; /* Single full-width column */
                    padding: 10px 25px;
                    gap: 0;
                }
                .move-row.collapsed > div:nth-child(2),
                .move-row.collapsed > div:nth-child(3) {
                    display: none;
                }
                .move-row.collapsed .copy-option {
                    display: none;
                }
                /* Improved Minimize Styles */
                .move-row-header {
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 4px;
                    margin-bottom: 5px;
                }
                .move-row-header:hover {
                    background-color: rgba(0,0,0,0.03);
                }
                .toggle-icon {
                    margin-right: 8px;
                    font-size: 0.8rem;
                    transition: transform 0.3s ease;
                    display: inline-block;
                    color: var(--text-secondary);
                }
                /* Rotate icon when collapsed (point right) */
                .move-row.collapsed .toggle-icon {
                    transform: rotate(-90deg);
                }

                /* Responsive Design */
                @media (max-width: 900px) {
                    .move-row {
                        grid-template-columns: 1fr !important;
                        gap: 15px;
                    }
                    /* Ensure tick options wrap nicely on smaller screens */
                    .tick-options {
                        flex-wrap: wrap;
                    }
                    #containerTicksB {
                        flex-wrap: wrap;
                    }
                }
            </style>

            <div style="margin-top:20px;">
                <!-- Row A -->
                <div class="move-row" id="rowA">
                    <div>
                        <div class="move-row-header" onclick="toggleRow('rowA')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-a" style="border:none; margin:0;">Folder A<br><small>(Non-Editable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeA" disabled> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvA" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (A)
                            <input type="file" id="csvInputA" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayA" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestA" class="button btn-danger" style="width:100%; font-size:0.8rem;" disabled>Select Folder A</button>
                        <div id="pathDestA" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row B -->
                <div class="move-row" id="rowB">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowB')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-b" style="border:none; margin:0;">Folder B<br><small>(Office Use: tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeB" disabled> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvB" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (B)
                            <input type="file" id="csvInputB" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayB" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestB" class="button btn-primary" style="width:100%; font-size:0.8rem;" disabled>Select Folder B</button>
                        <div id="pathDestB" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Extracted Tick Options for Row B -->
                <div class="tick-row-full" id="rowB-ticks">
                    <div class="tick-options">
                        <!-- Mode Selector -->
                        <div style="margin-bottom:10px; display:flex; flex-wrap:wrap; gap:15px; font-size:0.9rem; border-bottom:1px solid rgba(0,0,0,0.1); padding-bottom:10px; width:100%; justify-content:space-between;">
                            <label style="cursor:pointer; color:var(--text-primary);">
                                <input type="radio" name="tickMode" value="retain" checked disabled> Retain Original
                            </label>
                            <label style="cursor:pointer; color:var(--button-danger);">
                                <input type="radio" name="tickMode" value="force" disabled> Force Selection
                            </label>
                            <label style="cursor:pointer; color:var(--button-primary);">
                                <input type="radio" name="tickMode" value="add" disabled> Add Selection
                            </label>
                        </div>

                        <!-- Tick Container -->
                        <div id="containerTicksB" style="display:flex; gap:15px; opacity:0.5; pointer-events:none; align-items:center; flex-wrap:wrap; width:100%;">
                            <label><input type="checkbox" class="tick-opt-b" value="0"> adr</label>
                            <label><input type="checkbox" class="tick-opt-b" value="1"> brg</label>
                            <label><input type="checkbox" class="tick-opt-b" value="2"> cmp</label>
                            <label><input type="checkbox" class="tick-opt-b" value="3" checked> dta</label>
                            <label><input type="checkbox" class="tick-opt-b" value="4"> phn</label>
                            <label><input type="checkbox" class="tick-opt-b" value="5"> oth</label>
                        </div>
                    </div>
                </div>

                <!-- Row C -->
                <div class="move-row" id="rowC">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowC')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-c" style="border:none; margin:0;">Folder C<br><small>(Office Use: not tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeC" disabled> Copy Only</label>
                        <!-- Repair Template Toggle -->
                        <div style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
                            <label class="copy-option" title="Injects editable checkboxes from a template file">
                                <input type="checkbox" id="repairModeC" disabled> Repair Checkboxes
                            </label>
                        </div>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (C)
                            <input type="file" id="csvInputC" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayC" class="file-status">No CSV loaded</div>
                        
                        <!-- Template Input -->
                        <div id="repairTemplateContainer" style="display:none; margin-top:10px;">
                            <label class="button btn-warning" id="lblTemplateC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.8;">
                                Select Template PDF
                                <input type="file" id="templateInputC" accept=".pdf" style="display:none">
                            </label>
                            <div id="templateDisplayC" class="file-status">No Template loaded</div>
                        </div>
                    </div>
                    <div>
                        <button id="btnDestC" class="button btn-warning" style="width:100%; font-size:0.8rem;" disabled>Select Folder C</button>
                        <div id="pathDestC" class="file-status">Not Selected</div>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                    <input type="checkbox" id="generateSummaryCheckbox" checked>
                    Generate Summary CSV Report
                </label>
            </div>

            <div class="button-container">
                <button id="executeMoveBtn" class="button btn-primary" disabled>Execute Move</button>
                <button id="stopMoveBtn" class="button btn-warning" style="display:none;">Stop Move</button>
                <button id="resetBtn2" class="button btn-danger">Reset</button>
            </div>

             <div id="loading2" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Moving..." width="40">
                <p id="loadingText2">Moving files...</p>
            </div>

            <div id="moveResultsArea" class="results-section" style="display:none; margin-top:20px;">
                <div class="tab-container">
                    <button id="logTabBtnA" class="tab-btn active" onclick="showLogTab('A')">Folder A (Non-Editable) <span id="logCountA">0</span></button>
                    <button id="logTabBtnB" class="tab-btn" onclick="showLogTab('B')">Folder B (Office Use: tickable) <span id="logCountB">0</span></button>
                    <button id="logTabBtnC" class="tab-btn" onclick="showLogTab('C')">Folder C (Office Use: not tickable) <span id="logCountC">0</span></button>
                </div>

                <div id="moveListA" class="file-list"></div>
                <div id="moveListB" class="file-list" style="display:none"></div>
                <div id="moveListC" class="file-list" style="display:none"></div>
            </div>
        </div>

        <div id="processingTimeContainer" class="container" style="display: none; margin-top: 20px;">
             <p id="processingTime" class="status-message">Total processing time: <span id="time"></span></p>
        </div>

    </div>

    <script>
        // --- State Management ---
        let sourceDirHandle = null;
        let allFiles = []; // { name, path, handle, parentHandle, category, reason }
        
        // Phase 2 State
        let csvDataStore = { A: null, B: null, C: null };
        let destHandles = { A: null, B: null, C: null };
        let logCounts = { A: 0, B: 0, C: 0 }; // Track move counts
        let sourceDirHandle2 = null;
        
        // Repair Template State
        let repairTemplateBytes = null;
        let repairWidgetCoords = null; // [{x,y,w,h,name}, ...]

        let isProcessing = false; // Global stop flag

        // --- UI Toggles ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        });
        if (localStorage.getItem('darkMode') === 'enabled') document.documentElement.classList.add('dark-mode');

        // Phase Switching
        document.getElementById('btnPhase1').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'block';
            document.getElementById('phase2-container').style.display = 'none';
            document.getElementById('btnPhase1').classList.add('active');
            document.getElementById('btnPhase2').classList.remove('active');
        });
        document.getElementById('btnPhase2').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
        });

        // --- Phase 1: Analysis Logic ---

        document.getElementById('selectSourceBtn').addEventListener('click', async () => {
            try {
                sourceDirHandle = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay').textContent = `Selected: ${sourceDirHandle.name}`;
                document.getElementById('analyseBtn').disabled = false;
            } catch (err) { console.error(err); }
        });

        document.getElementById('analyseBtn').addEventListener('click', async () => {
            if (!sourceDirHandle) return;
            
            const loading = document.getElementById('loading1');
            const txt = document.getElementById('loadingText1');
            const stopBtn = document.getElementById('stopAnalyseBtn');
            const analyseBtn = document.getElementById('analyseBtn');
            const timeContainer = document.getElementById('processingTimeContainer');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            timeContainer.style.display = 'none';
            analyseBtn.disabled = true; // Prevent double click
            isProcessing = true;
            
            allFiles = [];
            resetLists();
            
            const startTime = performance.now();

            try {
                txt.textContent = "Scanning folders...";
                // Get selected scan mode
                const mode = document.querySelector('input[name="scanMode"]:checked').value;
                
                const filesToProcess = await scanForPdfsConcurrent(sourceDirHandle, mode);
                
                let processedCount = 0;
                const total = filesToProcess.length;
                
                // Helper for Dynamic Concurrency Pool
                async function runConcurrentPool(items, limit, taskFn) {
                    const results = [];
                    const executing = new Set();
                    
                    let lastUpdate = 0;

                    for (const item of items) {
                        if (!isProcessing) break;

                        const p = taskFn(item).then(res => {
                            executing.delete(p);
                            processedCount++;
                            
                            // Throttle UI updates to every 100ms
                            const now = Date.now();
                            if (now - lastUpdate > 100) {
                                lastUpdate = now;
                                requestAnimationFrame(() => {
                                    txt.textContent = `Analyzing ${processedCount}/${total}`;
                                });
                            }
                            
                            return res;
                        });
                        
                        results.push(p);
                        executing.add(p);
                        
                        if (executing.size >= limit) {
                            await Promise.race(executing);
                        }
                    }
                    return Promise.all(results);
                }

                const CONCURRENCY_LIMIT = 8; // Active workers
                const results = await runConcurrentPool(filesToProcess, CONCURRENCY_LIMIT, analysePdf);
                
                // Filter and store valid results
                results.forEach(r => {
                    if (r) allFiles.push(r);
                });

                displayResults();
                
                const endTime = performance.now();
                displayProcessingTime(startTime, endTime);

            } catch (error) {
                alert("Error during analysis: " + error.message);
                console.error(error);
            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                analyseBtn.disabled = false;
            }
        });
        
        document.getElementById('stopAnalyseBtn').addEventListener('click', () => {
            isProcessing = false;
            document.getElementById('loadingText1').textContent = "Stopping...";
        });

        // Concurrent Scan for KA*.pdf
        async function scanForPdfsConcurrent(dirHandle, mode = 'subfolders') {
            const results = [];
            const kaPattern = /^KA\d{8}.*\.pdf$/i;
            const queue = [{ handle: dirHandle, path: '', depth: 0 }];
            const MAX_CONCURRENT_DIRS = 8; // Chrome typically handles this well

            async function processDirectory(item) {
                const { handle, path, depth } = item;
                const subDirs = [];
                
                try {
                    for await (const entry of handle.values()) {
                         // Check stop flag
                        if (!isProcessing) return;

                        if (entry.kind === 'directory') {
                             // Logic: Recurse if mode is 'subfolders' or 'both'.
                            // Also, if mode is 'root', we STOP at depth 0.
                            if (mode !== 'root') {
                                 const subPath = path ? `${path}/${entry.name}` : entry.name;
                                 subDirs.push({ 
                                     handle: entry, 
                                     path: subPath, 
                                     depth: depth + 1 
                                 });
                            }
                        } else if (entry.kind === 'file') {
                            // Logic:
                            // If mode 'subfolders': Process only if depth > 0
                            // If mode 'root': Process only if depth == 0
                            // If mode 'both': Process all
                            let shouldProcess = false;
                            if (mode === 'both') shouldProcess = true;
                            else if (mode === 'root' && depth === 0) shouldProcess = true;
                            else if (mode === 'subfolders' && depth > 0) shouldProcess = true;

                            if (shouldProcess && kaPattern.test(entry.name)) {
                                results.push({
                                    name: entry.name,
                                    handle: entry,
                                    parentHandle: handle,
                                    relativePath: path ? `${path}/${entry.name}` : entry.name
                                });
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`Error reading ${handle.name}:`, e);
                }
                
                return subDirs;
            }

            while (queue.length > 0 && isProcessing) {
                const batch = queue.splice(0, MAX_CONCURRENT_DIRS);
                const batchResults = await Promise.all(batch.map(item => processDirectory(item)));
                
                // Add found subdirectories to queue
                batchResults.forEach(subDirs => {
                    if(subDirs) queue.push(...subDirs);
                });
            }

            return results;
        }

        function displayProcessingTime(startTime, endTime) {
            const totalTimeInSeconds = (endTime - startTime) / 1000;
            const hours = Math.floor(totalTimeInSeconds / 3600);
            const minutes = Math.floor((totalTimeInSeconds % 3600) / 60);
            const seconds = (totalTimeInSeconds % 60).toFixed(2);

            const timeSpan = document.getElementById('time');
            timeSpan.textContent = `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${seconds}s`;
            document.getElementById('processingTimeContainer').style.display = 'block';
        }

        // Core Analysis Logic
        async function analysePdf(fileObj) {
            // 1. Start: Default to Category 'A' (Non-Editable)
            // This ensures that any error, missing fields, or locked status defaults here.
            const res = { ...fileObj, category: 'A', reason: 'Default / Error / Non-Editable' };
            let pdf = null;

            try {
                const fileData = await fileObj.handle.getFile();
                const arrayBuffer = await fileData.arrayBuffer();

                // Load PDF
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                pdf = await loadingTask.promise;

                // --- CHECK 1: Page 1 Analysis (Is it Editable?) ---
                const page1 = await pdf.getPage(1);
                
                // Optional: Check Header (to ensure it's the right form type)
                const textContent1 = await page1.getTextContent();
                const page1Text = textContent1.items.map(item => item.str).join(' ');
                if (!page1Text.toLowerCase().includes("annual enterprise survey")) {
                     return { ...res, reason: 'Non-Editable' }; // Retain A
                }

                const p1Anns = await page1.getAnnotations();
                const p1Widgets = p1Anns.filter(a => a.subtype === 'Widget');

                // If no widgets on Page 1 -> Not editable form -> Stay A
                if (p1Widgets.length === 0) {
                    return { ...res, reason: 'No Form Fields on Page 1' }; // Retain A
                }

                // Check for Locked Fields on Page 1
                let p1EditableCount = 0;
                for (const w of p1Widgets) {
                    // Check readOnly flag or FieldFlags bit 1 (ReadOnly)
                    const isLocked = w.readOnly || (w.fieldFlags & 1) === 1;
                    if (!isLocked) {
                        p1EditableCount++;
                    }
                }

                // If NO field on Page 1 is editable -> Treat as Non-Editable -> Stay A
                // This allows forms with mixed locked/unlocked fields (like pre-filled ID) to pass.
                if (p1EditableCount === 0) {
                    return { ...res, reason: `Non-Editable (Page 1 has 0 editable fields)` }; // Retain A
                }

                // --- If we are here, Page 1 is Clean & Editable ---
                // Now we determine if it goes to B or C based on "Office Use" section.

                // --- CHECK 2: Office Use Section (Last Page) ---
                const lastPage = await pdf.getPage(pdf.numPages);
                const lastPageText = await lastPage.getTextContent();
                
                // Find "Office use" text
                const officeUseItem = lastPageText.items.find(item => 
                    item.str.toLowerCase().includes("office use") || 
                    item.str.toLowerCase().includes("office use:")
                );

                if (!officeUseItem) {
                    // If Office Use section is missing completely -> Treat as "Widgets Missing" -> Stay A
                    // (Or arguably C, but plan says 'Widgets missing -> Do nothing (Retain A)')
                    return { ...res, reason: 'Missing "Office use:" section' }; // Retain A
                }

                const textY = officeUseItem.transform[5]; 
                const anns = await lastPage.getAnnotations();
                
                // Find checkboxes physically below the "Office use" text
                // We use a loose threshold (+20) to handle minor alignment issues, 
                // but STRICTLY exclude boxes significantly higher up (user boxes).
                const relevantBoxes = anns.filter(a => 
                    a.subtype === 'Widget' && 
                    a.fieldType === 'Btn' && 
                    !a.radioButton &&
                    a.rect[1] < (textY + 20) // Must be below or just inline with the text
                );

                if (relevantBoxes.length === 0) {
                    // If text is found but no boxes in the office section, it's effectively "Not Tickable" -> C
                    return { ...res, category: 'C', reason: 'No checkboxes found in Office Use section' }; 
                }

                // Check if these specific OFFICE boxes are Editable
                let hasEditableOfficeBox = false;
                for (const box of relevantBoxes) {
                    const isReadOnly = box.readOnly || (box.fieldFlags & 1) === 1;
                    if (!isReadOnly) {
                        hasEditableOfficeBox = true;
                        break;
                    }
                }

                // --- FINAL OUTCOME ---
                if (hasEditableOfficeBox) {
                    // Page 1 Editable AND Office Use Tickable -> Folder B
                    return { ...res, category: 'B', reason: 'Page 1 Editable & Office Use Tickable' };
                } else {
                    // Page 1 Editable BUT Office Use Locked -> Folder C
                    return { ...res, category: 'C', reason: 'Page 1 Editable but Office Use Locked' };
                }

            } catch (err) {
                // Any error -> Stay A
                if (err.name === 'PasswordException') {
                    return { ...res, reason: 'Encrypted / Password Protected' };
                }
                return { ...res, reason: 'Error: ' + err.message };
            } finally {
                // CRITICAL MEMORY CLEANUP
                if (pdf) {
                    await pdf.destroy();
                }
            }
        }

        // Display Functions
        function resetLists() {
            document.getElementById('listA').innerHTML = '';
            document.getElementById('listB').innerHTML = '';
            document.getElementById('listC').innerHTML = '';
            document.getElementById('resultsArea').style.display = 'none';
        }

        function displayResults() {
            document.getElementById('resultsArea').style.display = 'block';
            
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => groups[f.category].push(f));

            document.getElementById('countA').textContent = groups.A.length;
            document.getElementById('countB').textContent = groups.B.length;
            document.getElementById('countC').textContent = groups.C.length;

            renderList('listA', groups.A);
            renderList('listB', groups.B);
            renderList('listC', groups.C);

            // Fix: Initialize view state to match the default active tab (A)
            // This ensures the correct Download button is visible immediately.
            showTab('A');
        }

        function renderList(id, files) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            files.forEach(f => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.title = "Ctrl+Click to open PDF in new tab"; // Hover Tooltip
                div.innerHTML = `
                    <span>${f.relativePath}</span>
                    <span class="reason-tag">${f.reason}</span>
                `;
                
                // Click to open
                div.addEventListener('click', async (e) => {
                    if (!e.ctrlKey && !e.metaKey) return; // specific user request
                    
                    // Add visited state
                    div.classList.add('visited');
                    
                    try {
                        const file = await f.handle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                        // Note: Revoke logic is tricky with open-in-new-tab, browser handles cleanup usually on close
                    } catch(e) {
                        alert("Could not open file: " + e.message);
                    }
                });

                container.appendChild(div);
            });
        }

        window.showTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`list${c}`).style.display = isMatch ? 'block' : 'none';
                // Show relevant download button
                document.getElementById(`downloadCsvBtn${c}`).style.display = isMatch ? 'inline-block' : 'none';
            });
            // Simple generic tab toggle
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            
            // Fix: Explicitly target the correct button via ID to avoid selector errors
            const activeBtn = document.getElementById(`tabBtn${cat}`);
            if (activeBtn) activeBtn.classList.add('active');
        };

        // CSV Export - Split into 3 functions
        function downloadCsvForCategory(cat) {
            const files = allFiles.filter(f => f.category === cat);
            if (files.length === 0) {
                alert(`No files in Category ${cat} to export.`);
                return;
            }
            
            let csv = "FilePath,FileName,Category,Reason,MoveStatus\n";
            files.forEach(f => {
                // Remove filename from path (get directory only)
                // relativePath is "Subfolder/File.pdf" -> "Subfolder"
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                let dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';

                // Prepend the root folder name to give context
                if (sourceDirHandle) {
                    dirPath = dirPath ? `${sourceDirHandle.name}/${dirPath}` : sourceDirHandle.name;
                }
                // Cleanup any trailing slashes if logic above left them (e.g. "Root/")
                if (dirPath.endsWith('/')) dirPath = dirPath.slice(0, -1);

                const path = `"${dirPath}"`; // Directory Only
                const reason = `"${f.reason}"`;
                csv += `${path},${f.name},${f.category},${reason},Pending\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pdf-analysis-${cat}-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
            a.click();
        }

        document.getElementById('downloadCsvBtnA').addEventListener('click', () => downloadCsvForCategory('A'));
        document.getElementById('downloadCsvBtnB').addEventListener('click', () => downloadCsvForCategory('B'));
        document.getElementById('downloadCsvBtnC').addEventListener('click', () => downloadCsvForCategory('C'));

        document.getElementById('resetBtn1').addEventListener('click', () => {
            allFiles = [];
            resetLists();
            document.getElementById('sourcePathDisplay').textContent = 'No folder selected';
            sourceDirHandle = null;
            document.getElementById('analyseBtn').disabled = true;
        });


        // --- Phase 2: Move Logic ---
        
        function setPhase2ControlsState(enabled) {
             // Copy Checkboxes
            ['A','B','C'].forEach(c => {
                const el = document.getElementById(`copyMode${c}`);
                if (el) el.disabled = !enabled;
            });
            
            // Tick Mode Radios
            document.querySelectorAll('input[name="tickMode"]').forEach(r => r.disabled = !enabled);
            
            // Tick Container: If disabled, force visual disable. If enabled, let logic decide based on radio.
            const container = document.getElementById('containerTicksB');
            if (!enabled) {
                container.style.opacity = '0.5';
                container.style.pointerEvents = 'none';
            } else {
                // If enabling, restore state based on currently checked radio
                const mode = document.querySelector('input[name="tickMode"]:checked').value;
                const isRetain = (mode === 'retain');
                if (!isRetain) {
                     container.style.opacity = '1';
                     container.style.pointerEvents = 'auto';
                }
            }
        }

        document.getElementById('selectSourceBtn2').addEventListener('click', async () => {
             try {
                sourceDirHandle2 = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name}`;
                
                // Enable CSV Inputs
                ['A', 'B', 'C'].forEach(cat => {
                    const lbl = document.getElementById(`lblCsv${cat}`);
                    const inp = document.getElementById(`csvInput${cat}`);
                    if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                    if(inp) { inp.disabled = false; }
                });
                
                // Enable Controls
                setPhase2ControlsState(true);

                checkMoveReady();
            } catch (err) { console.error(err); }
        });

        document.getElementById('copyModeC').addEventListener('change', () => checkRepairAvailability());

        function checkRepairAvailability() {
            // Repair mode only available if NOT copy mode (moving implies modifying? actually copying is fine too)
            // Logic: Just needs source folder selected.
            // Update: Repair is an optional checkbox.
            const repairToggle = document.getElementById('repairModeC');
            const templateContainer = document.getElementById('repairTemplateContainer');
            
            if (sourceDirHandle2) {
                repairToggle.disabled = false;
            }
            
            if (repairToggle.checked) {
                 templateContainer.style.display = 'block';
            } else {
                 templateContainer.style.display = 'none';
            }
        }
        
        document.getElementById('repairModeC').addEventListener('change', checkRepairAvailability);

        // Template Upload Handler
        document.getElementById('templateInputC').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const buffer = await file.arrayBuffer();
                repairTemplateBytes = buffer;
                
                // Scan for coords immediately
                const pdfDoc = await PDFLib.PDFDocument.load(buffer);
                const pageCount = pdfDoc.getPageCount();
                const lastPage = pdfDoc.getPage(pageCount - 1);
                
                // Extract Checkbox Widgets from last page
                // Re-using logic similar to finding them for scanned files, but using PDF-Lib
                const form = pdfDoc.getForm();
                const fields = form.getFields();
                const checkboxes = fields.filter(f => f instanceof PDFLib.PDFCheckBox);
                
                const candidates = [];
                
                for (const box of checkboxes) {
                    const widgets = box.acroField.getWidgets();
                    for (const w of widgets) {
                        const rect = w.getRectangle();
                        // Basic check: is it reasonably on the page?
                        // We need Y coord relative to something? No, absolute is fine if pages match.
                        candidates.push({
                             name: box.getName(),
                             x: rect.x,
                             y: rect.y,
                             w: rect.width,
                             h: rect.height
                        });
                    }
                }
                
                // Sort candidates by Y (ascending) then X
                candidates.sort((a, b) => {
                     const yDiff = Math.abs(a.y - b.y);
                     if (yDiff < 10) return a.x - b.x;
                     return a.y - b.y;
                });
                
                // Filter: Take the bottom-most row (first 6 in sorted list)
                // Expecting 6: adr, brg, cmp, dta, phn, oth
                if (candidates.length >= 6) {
                     repairWidgetCoords = candidates.slice(0, 6);
                     document.getElementById('templateDisplayC').textContent = `Loaded: ${file.name} (Found ${repairWidgetCoords.length} widgets)`;
                     document.getElementById('templateDisplayC').style.color = 'var(--button-primary)';
                } else {
                     repairTemplateBytes = null;
                     repairWidgetCoords = null;
                     document.getElementById('templateDisplayC').textContent = `Error: Found only ${candidates.length} checkboxes (Need 6)`;
                     document.getElementById('templateDisplayC').style.color = 'var(--button-danger)';
                     alert("Template Invalid: Could not find 6 checkboxes on the last page.");
                }
                
            } catch (err) {
                console.error(err);
                document.getElementById('templateDisplayC').textContent = "Error reading template";
            }
        });

        // CSV Inputs Handlers (A, B, C)
        ['A', 'B', 'C'].forEach(cat => {
            document.getElementById(`csvInput${cat}`).addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const text = await file.text();
                csvDataStore[cat] = parseCsv(text);
                document.getElementById(`csvDisplay${cat}`).textContent = `${file.name} (${csvDataStore[cat].length} rows)`;
                checkMoveReady();
            });
        });

        async function pickDest(cat) {
            try {
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' }); // Request write permission upfront
                destHandles[cat] = handle;
                document.getElementById(`pathDest${cat}`).textContent = handle.name;
                checkMoveReady();
            } catch(e) { console.error(e); }
        }

        document.getElementById('btnDestA').addEventListener('click', () => pickDest('A'));
        document.getElementById('btnDestB').addEventListener('click', () => pickDest('B'));
        document.getElementById('btnDestC').addEventListener('click', () => pickDest('C'));

        // Override Checkbox Toggle - UPDATED for 3-way Radio
        document.querySelectorAll('input[name="tickMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const container = document.getElementById('containerTicksB');
                const isRetain = (e.target.value === 'retain');
                if (isRetain) {
                    container.style.opacity = '0.5';
                    container.style.pointerEvents = 'none';
                } else {
                    container.style.opacity = '1';
                    container.style.pointerEvents = 'auto';
                }
            });
        });

        function checkMoveReady() {
            if (!sourceDirHandle2) {
                document.getElementById('executeMoveBtn').disabled = true;
                // Ensure buttons stay disabled if source not selected
                ['A', 'B', 'C'].forEach(c => {
                    document.getElementById(`btnDest${c}`).disabled = true;
                });
                return;
            }
            // Enable destination buttons if source is ready AND CSV is loaded for that row
            ['A', 'B', 'C'].forEach(c => {
                const hasCsv = !!csvDataStore[c];
                document.getElementById(`btnDest${c}`).disabled = !hasCsv; 
            });

            // Check if at least ONE row is fully ready (CSV + Folder)
            const readyA = csvDataStore.A && destHandles.A;
            const readyB = csvDataStore.B && destHandles.B;
            const readyC = csvDataStore.C && destHandles.C;

            document.getElementById('executeMoveBtn').disabled = !(readyA || readyB || readyC);
        }

        function parseCsv(text) {
            const lines = text.split('\n').filter(l => l.trim());
            // Simple check to see if header exists, assuming standard format
            const startIdx = lines[0].toLowerCase().startsWith('filepath') ? 1 : 0;
            
            // Improved Regex split to handle quoted fields
            const regex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
            
            const data = [];
            for(let i=startIdx; i<lines.length; i++) {
                const cols = lines[i].split(regex).map(s => s.replace(/^"|"$/g, '').trim());
                if(cols.length < 2) continue; // Need at least path and name
                data.push({
                    path: cols[0],
                    name: cols[1],
                    category: cols[2] || '',
                    reason: cols[3] || '' // Capture Reason (Column 4)
                });
            }
            return data;
        }

        document.getElementById('executeMoveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading2');
            const resultsArea = document.getElementById('moveResultsArea');
            
            // Reset Logs
            ['A', 'B', 'C'].forEach(c => {
                document.getElementById(`moveList${c}`).innerHTML = '';
                document.getElementById(`logCount${c}`).textContent = '0';
            });
            logCounts = { A: 0, B: 0, C: 0 };
            
            const generateSummary = document.getElementById('generateSummaryCheckbox').checked;
            const stopBtn = document.getElementById('stopMoveBtn');
            const execBtn = document.getElementById('executeMoveBtn');
            
            loading.style.display = 'block';
            resultsArea.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            execBtn.disabled = true;
            
            // Default to showing Log A initially
            showLogTab('A');
            
            isProcessing = true;
            const loadingText2 = document.getElementById('loadingText2');
            loadingText2.textContent = "Starting..."; // Reset default text
            
            const summaryData = []; // Store for CSV export

            try {
                // Iterate over categories A, B, C
                for (const cat of ['A', 'B', 'C']) {
                    if (!isProcessing) break; // Stop check outer loop
                    
                    const data = csvDataStore[cat];
                    const targetFolder = destHandles[cat];
                    const isCopyOnly = document.getElementById(`copyMode${cat}`).checked;

                    // Skip if not configured (CSV missing or Folder missing)
                    if (!data || !targetFolder) continue;

                    // Get selected tick indices for Category B
                    let selectedTickIndices = [];
                    if (cat === 'B') {
                        const opts = document.querySelectorAll('.tick-opt-b:checked');
                        opts.forEach(opt => selectedTickIndices.push(parseInt(opt.value)));
                    }

                    for (const row of data) {
                        if (!isProcessing) {
                            logMsg(cat, "SYSTEM", "", "Process stopped by user", "orange");
                            break; // Stop check inner loop
                        }

                        const action = isCopyOnly ? "Copying" : "Moving";
                        loadingText2.textContent = `${action} ${row.name}...`;

                        const summaryRow = {
                            FileName: row.name,
                            OriginalPath: row.path,
                            Category: cat,
                            DestinationFolder: targetFolder.name,
                            Status: 'Pending',
                            Message: ''
                        };

                        // 1. Find File in Source
                        // CSV Row Path is "Subfolder" (Directory). Filename is separate.
                        let rawPath = row.path || '';
                        // Remove quotes just in case
                        rawPath = rawPath.replace(/^"|"$/g, '');
                        let pathParts = rawPath.split('/').filter(p => p);

                        // FIX: If the CSV includes the root folder name (which we added), remove it
                        // so we don't look for Root inside Root.
                        if (pathParts.length > 0 && pathParts[0] === sourceDirHandle2.name) {
                            pathParts.shift();
                        }
                        
                        pathParts.push(row.name);

                        let currentHandle = sourceDirHandle2;
                        let fileHandle = null;
                        let parentHandle = sourceDirHandle2; 

                        try {
                            // Traverse
                            for(let i=0; i<pathParts.length; i++) {
                                const part = pathParts[i];
                                if (i === pathParts.length - 1) {
                                    fileHandle = await currentHandle.getFileHandle(part);
                                } else {
                                    currentHandle = await currentHandle.getDirectoryHandle(part);
                                    parentHandle = currentHandle;
                                }
                            }
                        } catch (e) {
                            logMsg(cat, row.name, row.reason, "File Not Found in Source", 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "File Not Found in Source";
                            summaryData.push(summaryRow);
                            continue;
                        }

                        // 2. Move
                        try {
                            let fileData = await fileHandle.getFile();
                            let fileArrayBuffer = await fileData.arrayBuffer();
                            
                            // === AUTOMATED MODIFICATION FOR CATEGORY B (Existing Logic) ===
                            // ... (Keep existing logic for B) ...
                            const tickMode = document.querySelector('input[name="tickMode"]:checked').value;
                            
                            if (cat === 'B' && tickMode !== 'retain') {
                                try {
                                    // Load with pdf-lib
                                    const pdfDoc = await PDFLib.PDFDocument.load(fileArrayBuffer);
                                    // ... (existing B logic) ...
                                    // To avoid re-writing the whole B block, I will rely on the context matching.
                                    // But wait, I need to insert the C logic alongside or after B.
                                    // Since I cannot "skip" blocks in Edit easily without replacing large chunks,
                                    // I will locate the END of the B block and insert C.
                                } catch(e) {} 
                            }
                            
                            // === AUTOMATED REPAIR FOR CATEGORY C ===
                            const repairMode = document.getElementById('repairModeC').checked;
                            if (cat === 'C' && repairMode && repairWidgetCoords) {
                                try {
                                    // Load with pdf-lib if not already loaded
                                    // Note: The 'B' block above loads it locally. We need to load it here if it wasn't loaded.
                                    // Actually, 'fileArrayBuffer' is the source.
                                    const pdfDoc = await PDFLib.PDFDocument.load(fileArrayBuffer);
                                    const pageCount = pdfDoc.getPageCount();
                                    const lastPage = pdfDoc.getPage(pageCount - 1);
                                    const form = pdfDoc.getForm();
                                    
                                    // 1. Draw White Masks over old boxes
                                    // 2. Create New Checkboxes
                                    
                                    const { width, height } = lastPage.getSize();
                                    
                                    repairWidgetCoords.forEach(coord => {
                                        // Removed Masking: We want the original underlying 3D-style box to show through.
                                        // We will place an invisible, clickable widget on top of it.
                                        
                                        // Create Checkbox
                                        // Ideally we want standard names. "adr", "brg".
                                        
                                        try {
                                            const newBox = form.createCheckBox(coord.name);
                                            newBox.addToPage(lastPage, {
                                                x: coord.x,
                                                y: coord.y,
                                                width: coord.w,
                                                height: coord.h,
                                                textColor: PDFLib.rgb(0, 0, 0),
                                                // No backgroundColor -> Transparent
                                                // No borderColor -> Transparent/Invisible border
                                                borderWidth: 0,
                                            });
                                        } catch (err) {
                                            // Field might already exist? If so, try to revive it?
                                            // If it exists but is broken, maybe we can't easily replace it with the same name.
                                            // Let's try a fallback name if collision.
                                            // summaryRow.Message += ` [Field ${coord.name} collision]`;
                                            // Actually, if we are repairing, maybe we should delete the old field first?
                                            // But usually C files are "Not Tickable" because fields are MISSING (just image) or Locked.
                                            
                                            // Just in case, try getting the existing field
                                            try {
                                                const existing = form.getField(coord.name);
                                                // If it exists, maybe we just unlock it and move it?
                                                // Or just ignore creating new one?
                                                // If it exists, it might be the read-only one.
                                                if (existing) {
                                                    // enableReadOnly(false)?
                                                    // existing.enableReadOnly(false); // Not direct method in all versions
                                                    // pdf-lib doesn't strictly have "enableReadOnly(false)" easy access on high level API always.
                                                    // But let's assume for now we are creating NEW ones because C usually means "Image Only".
                                                }
                                            } catch(ex) {}
                                        }
                                    });
                                    
                                    fileArrayBuffer = await pdfDoc.save();
                                    summaryRow.Message += " [Repaired]";
                                    
                                } catch (err) {
                                    console.error(err);
                                    summaryRow.Message += ` [Repair Failed: ${err.message}]`;
                                }
                            }
                            // =============================================

                            // Determine Destination Directory
                            // For Category A: Retain the source folder structure
                            let finalDestHandle = targetFolder;
                            if (cat === 'A') {
                                // pathParts currently holds [dir1, dir2, ..., filename]
                                // We only want the directories.
                                const dirsOnly = pathParts.slice(0, -1);
                                for (const part of dirsOnly) {
                                    finalDestHandle = await finalDestHandle.getDirectoryHandle(part, { create: true });
                                }
                            }

                            // Check collision
                            let newName = row.name;
                            try {
                                await finalDestHandle.getFileHandle(newName);
                                newName = newName.replace('.pdf', `_${Date.now()}.pdf`);
                            } catch(e) {}

                            const newFileHandle = await finalDestHandle.getFileHandle(newName, { create: true });
                            const writable = await newFileHandle.createWritable();
                            // Write the (potentially modified) buffer
                            await writable.write(fileArrayBuffer);
                            await writable.close();

                            if (!isCopyOnly) {
                                await parentHandle.removeEntry(fileHandle.name);
                                logMsg(cat, row.name, row.reason, "Moved", 'green', newFileHandle);
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Moved]`;
                            } else {
                                logMsg(cat, row.name, row.reason, "Copied", 'blue', newFileHandle);
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Copied]`;
                            }

                        } catch (e) {
                            logMsg(cat, row.name, row.reason, "Error Moving: " + e.message, 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "Error Moving: " + e.message;
                        }
                        
                        summaryData.push(summaryRow);
                    }
                }
                
                // Generate Summary CSV (Even if stopped)
                if (generateSummary && summaryData.length > 0) {
                     let csvContent = "FileName,OriginalPath,Category,DestinationFolder,Status,Message\n";
                     summaryData.forEach(row => {
                         const escape = (val) => `"${String(val).replace(/"/g, '""')}"`;
                         csvContent += `${escape(row.FileName)},${escape(row.OriginalPath)},${escape(row.Category)},${escape(row.DestinationFolder)},${escape(row.Status)},${escape(row.Message)}\n`;
                     });
                     
                     const blob = new Blob([csvContent], { type: 'text/csv' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = `move-summary-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
                     document.body.appendChild(a); 
                     a.click();
                     document.body.removeChild(a);
                }

            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                // We don't auto-enable execBtn because state might need reset or re-check, 
                // but usually it's safe to re-enable if they want to try again.
                execBtn.disabled = false; 
                checkMoveReady(); // Re-verify state
            }
        });
        
        document.getElementById('stopMoveBtn').addEventListener('click', () => {
            isProcessing = false;
            // Show stopping status in all logs? Or just UI text.
            // logMsg("A", "SYSTEM", "Stopping... finishing current file...", "orange"); 
            document.getElementById('loadingText2').textContent = "Stopping...";
        });

        function logMsg(cat, name, reason, msg, color, fileHandle = null) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `<span>${name}</span> <span class="reason-tag">${reason || ''}</span> <span style="color:${color}">${msg}</span>`;
            
            if (fileHandle) {
                div.title = "Ctrl+Click to open moved file";
                div.style.cursor = "pointer";
                div.addEventListener('click', async (e) => {
                    if (!e.ctrlKey && !e.metaKey) return;
                    
                    // Add visited state
                    div.classList.add('visited');
                    
                    try {
                        const file = await fileHandle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                    } catch (err) {
                        alert("Error opening file: " + err.message);
                    }
                });
            }

            const container = document.getElementById(`moveList${cat}`);
            if(container) {
                container.appendChild(div);
                // Update count
                logCounts[cat]++;
                document.getElementById(`logCount${cat}`).textContent = logCounts[cat];
            }
        }

        // Phase 2 Tab Switching
        window.showLogTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`moveList${c}`).style.display = isMatch ? 'block' : 'none';
                
                const btn = document.getElementById(`logTabBtn${c}`);
                if(isMatch) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        };

        document.getElementById('resetBtn2').addEventListener('click', () => {
            // Reload page for full clean slate
            window.location.reload();
        });

        window.toggleRow = function(rowId) {
            const row = document.getElementById(rowId);
            row.classList.toggle('collapsed');
        };
    </script>
</body>
</html>
