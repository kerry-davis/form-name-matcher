<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Sorter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        :root {
            --bg-primary: #f4f6f9;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #4b4b6a;
            --accent-primary: #6a5acd;
            --accent-secondary: #4a4a6a;
            --button-primary: #4CAF50;
            --button-secondary: #2196F3;
            --button-danger: #FF6B6B;
            --button-warning: #FF9800;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --bg-primary: #16213e;
            --bg-secondary: #0f3460;
            --text-primary: #e5e5e5;
            --text-secondary: #c0c0c0;
            --accent-primary: #6a5acd;
            --accent-secondary: #7b68ee;
            --button-primary: #388E3C;
            --button-secondary: #1976D2;
            --button-danger: #FF5252;
            --button-warning: #F57C00;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; transition: all 0.3s ease; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .toggle-icons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toggle-icons button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 100%;
            max-width: 900px;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-primary); }
        h3 { margin-bottom: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            color: white;
            font-size: 0.9rem;
        }
        
        .button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--button-primary); }
        .btn-secondary { background-color: var(--button-secondary); }
        .btn-danger { background-color: var(--button-danger); }
        .btn-warning { background-color: var(--button-warning); }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            word-break: break-all;
        }

        .results-section { display: none; }
        
        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .tab-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .file-list {
            height: 300px;
            overflow-y: auto;
            background: rgba(0,0,0,0.02);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            cursor: pointer; /* Visual cue */
        }
        
        .file-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .file-item:last-child { border-bottom: none; }
        .reason-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-secondary);
            color: white;
            margin-left: 10px;
        }

        .loading { display: none; text-align: center; margin: 20px; }
        
        .phase-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        .phase-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding-bottom: 5px;
        }

        .phase-btn.active {
            color: var(--accent-primary);
            border-bottom: 3px solid var(--accent-primary);
            font-weight: bold;
        }

        #phase2-container { display: none; }

        /* Special coloring for categories */
        .cat-a { color: var(--button-danger); } /* Non-Editable */
        .cat-b { color: var(--button-primary); } /* Tickable */
        .cat-c { color: var(--button-warning); } /* Locked/Other */

    </style>
</head>
<body>
    <div class="toggle-icons">
        <button id="darkModeToggle">ðŸŒ“</button>
    </div>

    <div class="container">
        <h1>PDF Form Sorter</h1>
        
        <div class="phase-selector">
            <button class="phase-btn active" id="btnPhase1">1. Analyze & Export</button>
            <button class="phase-btn" id="btnPhase2">2. Move via CSV</button>
        </div>

        <!-- Phase 1: Analyze -->
        <div id="phase1-container">
            <div class="button-container">
                <button id="selectSourceBtn" class="button btn-secondary">Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay" class="status-box">No folder selected</div>

            <div class="button-container">
                <button id="analyzeBtn" class="button btn-primary" disabled>Analyze PDFs</button>
                <button id="resetBtn1" class="button btn-danger">Reset</button>
            </div>

            <div id="loading1" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Processing..." width="40">
                <p id="loadingText1">Scanning...</p>
            </div>

            <div id="resultsArea" class="results-section">
                <div class="tab-container">
                    <button class="tab-btn active" onclick="showTab('A')">Folder A (Non-Editable) <span id="countA">0</span></button>
                    <button class="tab-btn" onclick="showTab('B')">Folder B (Tickable) <span id="countB">0</span></button>
                    <button class="tab-btn" onclick="showTab('C')">Folder C (Locked/Other) <span id="countC">0</span></button>
                </div>

                <div id="listA" class="file-list"></div>
                <div id="listB" class="file-list" style="display:none"></div>
                <div id="listC" class="file-list" style="display:none"></div>

                <div class="button-container">
                    <button id="downloadCsvBtnA" class="button btn-danger" style="display:none;">Download Category A CSV</button>
                    <button id="downloadCsvBtnB" class="button btn-primary" style="display:none;">Download Category B CSV</button>
                    <button id="downloadCsvBtnC" class="button btn-warning" style="display:none;">Download Category C CSV</button>
                </div>
            </div>
        </div>

        <!-- Phase 2: Move -->
        <div id="phase2-container">
            <p style="text-align:center; color:var(--text-secondary); margin-bottom:20px;">
                Use the CSV generated in Phase 1 (optionally edited) to move files to their destinations.
            </p>

            <div class="button-container">
                <button id="selectSourceBtn2" class="button btn-secondary">1. Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay2" class="status-box">No source folder selected</div>

            <div class="button-container">
                <label class="button btn-secondary" style="display:inline-block">
                    2. Select CSV File
                    <input type="file" id="csvInput" accept=".csv" style="display:none">
                </label>
            </div>
            <div id="csvDisplay" class="status-box">No CSV selected</div>

            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:20px;">
                <div>
                    <button id="btnDestA" class="button btn-danger" style="width:100%" disabled>3. Select Folder A</button>
                    <div id="pathDestA" class="status-box" style="font-size:0.7em">Not Selected</div>
                </div>
                <div>
                    <button id="btnDestB" class="button btn-primary" style="width:100%" disabled>3. Select Folder B</button>
                    <div id="pathDestB" class="status-box" style="font-size:0.7em">Not Selected</div>
                </div>
                <div>
                    <button id="btnDestC" class="button btn-warning" style="width:100%" disabled>3. Select Folder C</button>
                    <div id="pathDestC" class="status-box" style="font-size:0.7em">Not Selected</div>
                </div>
            </div>

            <div class="button-container">
                <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                    <input type="checkbox" id="generateSummaryCheckbox" checked>
                    Generate Summary CSV Report
                </label>
            </div>

            <div class="button-container">
                <button id="executeMoveBtn" class="button btn-primary" disabled>Execute Move</button>
                <button id="resetBtn2" class="button btn-danger">Reset</button>
            </div>

             <div id="loading2" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Moving..." width="40">
                <p id="loadingText2">Moving files...</p>
            </div>

            <div id="moveLog" class="file-list" style="display:none; height: 200px;"></div>
        </div>

    </div>

    <script>
        // --- State Management ---
        let sourceDirHandle = null;
        let allFiles = []; // { name, path, handle, parentHandle, category, reason }
        
        // Phase 2 State
        let csvData = null;
        let destHandles = { A: null, B: null, C: null };
        let sourceDirHandle2 = null;

        // --- UI Toggles ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        });
        if (localStorage.getItem('darkMode') === 'enabled') document.documentElement.classList.add('dark-mode');

        // Phase Switching
        document.getElementById('btnPhase1').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'block';
            document.getElementById('phase2-container').style.display = 'none';
            document.getElementById('btnPhase1').classList.add('active');
            document.getElementById('btnPhase2').classList.remove('active');
        });
        document.getElementById('btnPhase2').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
        });

        // --- Phase 1: Analysis Logic ---

        document.getElementById('selectSourceBtn').addEventListener('click', async () => {
            try {
                sourceDirHandle = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay').textContent = `Selected: ${sourceDirHandle.name}`;
                document.getElementById('analyzeBtn').disabled = false;
            } catch (err) { console.error(err); }
        });

        document.getElementById('analyzeBtn').addEventListener('click', async () => {
            if (!sourceDirHandle) return;
            
            const loading = document.getElementById('loading1');
            const txt = document.getElementById('loadingText1');
            loading.style.display = 'block';
            allFiles = [];
            resetLists();
            
            try {
                txt.textContent = "Scanning folders...";
                const filesToProcess = await scanForPdfs(sourceDirHandle);
                
                let processed = 0;
                for (const file of filesToProcess) {
                    processed++;
                    txt.textContent = `Analyzing ${processed}/${filesToProcess.length}: ${file.name}`;
                    
                    const result = await analyzePdf(file);
                    allFiles.push(result);
                }

                displayResults();
            } catch (error) {
                alert("Error during analysis: " + error.message);
                console.error(error);
            } finally {
                loading.style.display = 'none';
            }
        });

        // Recursive Scan for KA*.pdf in subfolders
        async function scanForPdfs(dirHandle, path = '') {
            let results = [];
            const kaPattern = /^KA\d{8}.*\.pdf$/i;

            try {
                for await (const entry of dirHandle.values()) {
                    try {
                        if (entry.kind === 'directory') {
                            // Go deeper - PASS entry as the new parentHandle for the recursive call logic
                            const subPath = path ? `${path}/${entry.name}` : entry.name;
                            const subResults = await scanForPdfs(entry, subPath);
                            results = results.concat(subResults);
                        } else if (entry.kind === 'file') {
                            // Check filename pattern
                            if (kaPattern.test(entry.name)) {
                                results.push({
                                    name: entry.name,
                                    handle: entry,
                                    parentHandle: dirHandle, // CRITICAL FIX: Use the current dirHandle context
                                    relativePath: path ? `${path}/${entry.name}` : entry.name
                                });
                            }
                        }
                    } catch (innerErr) {
                        console.warn(`Skipping entry ${entry.name} due to error:`, innerErr);
                    }
                }
            } catch (dirErr) {
                console.warn(`Error reading directory ${dirHandle.name}:`, dirErr);
            }
            return results;
        }

        // Core Analysis Logic
        async function analyzePdf(fileObj) {
            // Default Result
            const res = { ...fileObj, category: 'C', reason: 'Unknown' };

            try {
                // MOVED INSIDE TRY BLOCK: File Reading
                const fileData = await fileObj.handle.getFile();
                const arrayBuffer = await fileData.arrayBuffer();

                // 1. Load PDF
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                const pdf = await loadingTask.promise;

                // 2. Check Page 1 Header ("Annual Enterprise Survey")
                const page1 = await pdf.getPage(1);
                const textContent1 = await page1.getTextContent();
                const page1Text = textContent1.items.map(item => item.str).join(' ');
                
                if (!page1Text.toLowerCase().includes("annual enterprise survey")) {
                    return { ...res, category: 'A', reason: 'Not Survey Form' };
                }

                // 3. Check Encryption / Form Fields
                // PDF.js handles encryption automatically by throwing PasswordException usually, 
                // but we can check stats.
                // Simplified: If we got here, it's readable. Check for form fields.
                // Note: retrieving annotations from all pages to count fields
                let totalFields = 0;
                for (let i = 1; i <= pdf.numPages; i++) {
                    const p = await pdf.getPage(i);
                    const anns = await p.getAnnotations();
                    const widgets = anns.filter(a => a.subtype === 'Widget');
                    totalFields += widgets.length;
                }

                if (totalFields === 0) {
                    return { ...res, category: 'A', reason: 'No Form Fields' };
                }

                // 4. Last Page Analysis ("Office use:" + Tickboxes)
                const lastPage = await pdf.getPage(pdf.numPages);
                
                // Get Text "Office use:" Position
                const lastPageText = await lastPage.getTextContent();
                const officeUseItem = lastPageText.items.find(item => 
                    item.str.toLowerCase().includes("office use") || 
                    item.str.toLowerCase().includes("office use:")
                );

                if (!officeUseItem) {
                    return { ...res, category: 'C', reason: 'Missing "Office use:" section' };
                }

                // PDF Coordinates: Origin (0,0) is usually Bottom-Left.
                // So "Below" text means Y < officeUseItem.transform[5]
                const textY = officeUseItem.transform[5]; 

                // Get Checkboxes
                const anns = await lastPage.getAnnotations();
                const checkboxes = anns.filter(a => 
                    a.subtype === 'Widget' && 
                    a.fieldType === 'Btn' && 
                    !a.radioButton // Button but not radio
                );

                // Filter spatially below the text
                // Note: annotation rect is [x1, y1, x2, y2]. y1/y2 depend on rotation, but generally smaller Y is lower on page.
                const relevantBoxes = checkboxes.filter(box => {
                    const boxY = box.rect[1]; // Bottom Y
                    return boxY < textY; // It is physically below the text header
                });

                if (relevantBoxes.length === 0) {
                    return { ...res, category: 'C', reason: 'No checkboxes in Office Use section' };
                }

                // Check Editability of these boxes
                let hasEditable = false;
                for (const box of relevantBoxes) {
                    // Bit 1 in FieldFlags = ReadOnly
                    const isReadOnly = box.readOnly || (box.fieldFlags & 1) === 1;
                    if (!isReadOnly) {
                        hasEditable = true;
                        break;
                    }
                }

                if (hasEditable) {
                    return { ...res, category: 'B', reason: 'Tickable Box Found' };
                } else {
                    return { ...res, category: 'C', reason: 'Boxes Locked' };
                }

            } catch (err) {
                if (err.name === 'PasswordException') {
                    return { ...res, category: 'A', reason: 'Encrypted' };
                }
                return { ...res, category: 'A', reason: 'Error: ' + err.message };
            }
        }

        // Display Functions
        function resetLists() {
            document.getElementById('listA').innerHTML = '';
            document.getElementById('listB').innerHTML = '';
            document.getElementById('listC').innerHTML = '';
            document.getElementById('resultsArea').style.display = 'none';
        }

        function displayResults() {
            document.getElementById('resultsArea').style.display = 'block';
            
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => groups[f.category].push(f));

            document.getElementById('countA').textContent = groups.A.length;
            document.getElementById('countB').textContent = groups.B.length;
            document.getElementById('countC').textContent = groups.C.length;

            renderList('listA', groups.A);
            renderList('listB', groups.B);
            renderList('listC', groups.C);
        }

        function renderList(id, files) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            files.forEach(f => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.title = "Click to open PDF in new tab"; // Hover Tooltip
                div.innerHTML = `
                    <span>${f.relativePath}</span>
                    <span class="reason-tag">${f.reason}</span>
                `;
                
                // Click to open
                div.addEventListener('click', async () => {
                    try {
                        const file = await f.handle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                        // Note: Revoke logic is tricky with open-in-new-tab, browser handles cleanup usually on close
                    } catch(e) {
                        alert("Could not open file: " + e.message);
                    }
                });

                container.appendChild(div);
            });
        }

        window.showTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`list${c}`).style.display = isMatch ? 'block' : 'none';
                // Show relevant download button
                document.getElementById(`downloadCsvBtn${c}`).style.display = isMatch ? 'inline-block' : 'none';
            });
            // Simple generic tab toggle
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
        };

        // CSV Export - Split into 3 functions
        function downloadCsvForCategory(cat) {
            const files = allFiles.filter(f => f.category === cat);
            if (files.length === 0) {
                alert(`No files in Category ${cat} to export.`);
                return;
            }
            
            let csv = "FilePath,FileName,Category,Reason,MoveStatus\n";
            files.forEach(f => {
                // Remove filename from path (get directory only)
                // relativePath is "Subfolder/File.pdf" -> "Subfolder"
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                const dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';

                const path = `"${dirPath}"`; // Directory Only
                const reason = `"${f.reason}"`;
                csv += `${path},${f.name},${f.category},${reason},Pending\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pdf-analysis-${cat}-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
            a.click();
        }

        document.getElementById('downloadCsvBtnA').addEventListener('click', () => downloadCsvForCategory('A'));
        document.getElementById('downloadCsvBtnB').addEventListener('click', () => downloadCsvForCategory('B'));
        document.getElementById('downloadCsvBtnC').addEventListener('click', () => downloadCsvForCategory('C'));

        document.getElementById('resetBtn1').addEventListener('click', () => {
            allFiles = [];
            resetLists();
            document.getElementById('sourcePathDisplay').textContent = 'No folder selected';
            sourceDirHandle = null;
            document.getElementById('analyzeBtn').disabled = true;
        });


        // --- Phase 2: Move Logic ---

        document.getElementById('selectSourceBtn2').addEventListener('click', async () => {
             try {
                sourceDirHandle2 = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name}`;
                checkMoveReady();
            } catch (err) { console.error(err); }
        });

        document.getElementById('csvInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const text = await file.text();
            csvData = parseCsv(text);
            document.getElementById('csvDisplay').textContent = `Loaded ${csvData.length} rows from ${file.name}`;
            checkMoveReady();
        });

        async function pickDest(cat) {
            try {
                const handle = await window.showDirectoryPicker();
                destHandles[cat] = handle;
                document.getElementById(`pathDest${cat}`).textContent = handle.name;
                checkMoveReady();
            } catch(e) {}
        }

        document.getElementById('btnDestA').addEventListener('click', () => pickDest('A'));
        document.getElementById('btnDestB').addEventListener('click', () => pickDest('B'));
        document.getElementById('btnDestC').addEventListener('click', () => pickDest('C'));

        function checkMoveReady() {
            const ready = sourceDirHandle2 && csvData && (destHandles.A || destHandles.B || destHandles.C);
            document.getElementById('executeMoveBtn').disabled = !ready;
            
            ['A', 'B', 'C'].forEach(c => {
                document.getElementById(`btnDest${c}`).disabled = !sourceDirHandle2;
            });
        }

        function parseCsv(text) {
            const lines = text.split('\n').filter(l => l.trim());
            const headers = lines[0].split(','); // Assuming simple CSV
            // We expect FilePath, FileName, Category
            // Handling potential quotes in CSV parsing is tricky with simple split, 
            // but sticking to simple for this POC unless complex paths expected.
            
            // Improved Regex split to handle quoted fields
            const regex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
            
            const data = [];
            for(let i=1; i<lines.length; i++) {
                const cols = lines[i].split(regex).map(s => s.replace(/^"|"$/g, '').trim());
                if(cols.length < 3) continue;
                data.push({
                    path: cols[0],
                    name: cols[1],
                    category: cols[2]
                });
            }
            return data;
        }

        document.getElementById('executeMoveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading2');
            const log = document.getElementById('moveLog');
            const generateSummary = document.getElementById('generateSummaryCheckbox').checked;
            
            loading.style.display = 'block';
            log.style.display = 'block';
            log.innerHTML = '';
            
            const summaryData = []; // Store for CSV export

            try {
                for (const row of csvData) {
                    const cat = row.category.trim().toUpperCase();
                    const targetFolder = destHandles[cat];
                    
                    const summaryRow = {
                        FileName: row.name,
                        OriginalPath: row.path,
                        Category: cat,
                        DestinationFolder: targetFolder ? targetFolder.name : 'N/A',
                        Status: 'Pending',
                        Message: ''
                    };
                    
                    // If no folder selected for this category, skip
                    if (!targetFolder) {
                        logMsg(row.name, "Skipped - No destination folder for Category " + cat, 'grey');
                        summaryRow.Status = 'Skipped';
                        summaryRow.Message = "No destination folder for Category " + cat;
                        summaryData.push(summaryRow);
                        continue;
                    }

                    // 1. Find File in Source
                    // CSV Row Path is now just "Subfolder" (Directory). Filename is separate.
                    // We need to reconstruct: Subfolder + / + FileName
                    
                    // IMPORTANT: We need to split by '/' but handle potential OS path separators if manual CSV editing happened.
                    // Assuming standard forward slash from our export.
                    let pathParts = row.path ? row.path.split('/') : [];
                    // Filter empty parts (e.g. if path was empty string for root)
                    pathParts = pathParts.filter(p => p);
                    
                    // Add the filename to the end to find the specific file object
                    pathParts.push(row.name);

                    let currentHandle = sourceDirHandle2;
                    let fileHandle = null;
                    let parentHandle = sourceDirHandle2; // To delete later

                    try {
                        // Traverse to file
                        // Note: pathParts includes filename at the end
                        for(let i=0; i<pathParts.length; i++) {
                            const part = pathParts[i];
                            if (i === pathParts.length - 1) {
                                // This is the file
                                fileHandle = await currentHandle.getFileHandle(part);
                            } else {
                                // This is a folder
                                currentHandle = await currentHandle.getDirectoryHandle(part);
                                parentHandle = currentHandle;
                            }
                        }
                    } catch (e) {
                        logMsg(row.name, "File Not Found in Source", 'red');
                        summaryRow.Status = 'Failed';
                        summaryRow.Message = "File Not Found in Source";
                        summaryData.push(summaryRow);
                        continue;
                    }

                    // 2. Move (Copy -> Delete)
                    try {
                        const fileData = await fileHandle.getFile();
                        // Check collision
                        let newName = row.name;
                        try {
                            await targetFolder.getFileHandle(newName);
                            // If exists, append timestamp
                            newName = newName.replace('.pdf', `_${Date.now()}.pdf`);
                        } catch(e) { /* Not found = good */ }

                        // Create new
                        const newFileHandle = await targetFolder.getFileHandle(newName, { create: true });
                        const writable = await newFileHandle.createWritable();
                        await writable.write(fileData);
                        await writable.close();

                        // Delete old
                        await parentHandle.removeEntry(fileHandle.name);

                        logMsg(row.name, `Moved to Folder ${cat}`, 'green');
                        summaryRow.Status = 'Success';
                        summaryRow.Message = `Moved to Folder ${cat}`;

                    } catch (e) {
                        logMsg(row.name, "Error Moving: " + e.message, 'red');
                        summaryRow.Status = 'Failed';
                        summaryRow.Message = "Error Moving: " + e.message;
                    }
                    
                    summaryData.push(summaryRow);
                }
                
                // Generate and Download Summary CSV if requested
                if (generateSummary && summaryData.length > 0) {
                     let csvContent = "FileName,OriginalPath,Category,DestinationFolder,Status,Message\n";
                     summaryData.forEach(row => {
                         const escape = (val) => `"${String(val).replace(/"/g, '""')}"`;
                         csvContent += `${escape(row.FileName)},${escape(row.OriginalPath)},${escape(row.Category)},${escape(row.DestinationFolder)},${escape(row.Status)},${escape(row.Message)}\n`;
                     });
                     
                     const blob = new Blob([csvContent], { type: 'text/csv' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = `move-summary-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
                     document.body.appendChild(a); // Append for Firefox support
                     a.click();
                     document.body.removeChild(a);
                }

            } finally {
                loading.style.display = 'none';
            }
        });

        function logMsg(name, msg, color) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `<span>${name}</span><span style="color:${color}">${msg}</span>`;
            document.getElementById('moveLog').appendChild(div);
        }

        document.getElementById('resetBtn2').addEventListener('click', () => {
             sourceDirHandle2 = null;
             csvData = null;
             destHandles = { A:null, B:null, C:null };
             document.getElementById('sourcePathDisplay2').textContent = 'No source folder selected';
             document.getElementById('csvDisplay').textContent = 'No CSV selected';
             document.getElementById('pathDestA').textContent = 'Not Selected';
             document.getElementById('pathDestB').textContent = 'Not Selected';
             document.getElementById('pathDestC').textContent = 'Not Selected';
             document.getElementById('csvInput').value = '';
             document.getElementById('moveLog').innerHTML = '';
             checkMoveReady();
        });

    </script>
</body>
</html>
