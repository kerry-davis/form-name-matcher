<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Sorter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        // Fix for standard font loading error
        pdfjsLib.GlobalWorkerOptions.standardFontDataUrl = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/standard_fonts/';
    </script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <style>
        :root {
            --bg-primary: #f4f6f9;
            --bg-secondary: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #4b4b6a;
            --accent-primary: #6a5acd;
            --accent-secondary: #4a4a6a;
            --button-primary: #4CAF50;
            --button-secondary: #2196F3;
            --button-danger: #FF6B6B;
            --button-warning: #FF9800;
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html.dark-mode {
            --bg-primary: #16213e;
            --bg-secondary: #0f3460;
            --text-primary: #e5e5e5;
            --text-secondary: #c0c0c0;
            --accent-primary: #6a5acd;
            --accent-secondary: #7b68ee;
            --button-primary: #388E3C;
            --button-secondary: #1976D2;
            --button-danger: #FF5252;
            --button-warning: #F57C00;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.2);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; transition: all 0.3s ease; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .toggle-icons {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toggle-icons button {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
        }

        .container {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow-color);
            width: 100%;
            max-width: 900px;
            padding: 30px;
            margin-bottom: 20px;
        }

        h1, h2 { text-align: center; margin-bottom: 20px; color: var(--accent-primary); }
        h3 { margin-bottom: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            color: white;
            font-size: 0.9rem;
        }
        
        .button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background-color: var(--button-primary); }
        .btn-secondary { background-color: var(--button-secondary); }
        .btn-danger { background-color: var(--button-danger); }
        .btn-warning { background-color: var(--button-warning); }

        .status-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9em;
            word-break: break-all;
        }

        .results-section { display: none; }
        
        .tab-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
        }

        .tab-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .file-list {
            height: 300px;
            overflow-y: auto;
            background: rgba(0,0,0,0.02);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            resize: vertical; /* Allow vertical resizing */
            min-height: 150px;
        }

        .file-item {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            cursor: pointer; /* Visual cue */
        }
        
        .file-item:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .file-item.visited {
            background-color: rgba(106, 90, 205, 0.1); /* Subtle purple highlight */
            border-left: 3px solid var(--accent-primary);
        }
        
        .file-item:last-child { border-bottom: none; }
        .reason-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--accent-secondary);
            color: white;
            margin-left: 10px;
        }

        .loading { display: none; text-align: center; margin: 20px; }
        
        .phase-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 20px;
        }

        .phase-btn {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding-bottom: 5px;
        }

        .phase-btn.active {
            color: var(--accent-primary);
            border-bottom: 3px solid var(--accent-primary);
            font-weight: bold;
        }

        #phase2-container { display: none; }

        /* Special coloring for categories */
        .cat-a { color: var(--button-danger); } /* Non-Editable */
        .cat-b { color: var(--button-primary); } /* Tickable */
        .cat-c { color: var(--button-warning); } /* Locked/Other */

        /* Processing Time Display */
        .status-message {
            text-align: center;
            margin: 10px 0;
            color: var(--text-secondary);
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="toggle-icons">
        <button id="darkModeToggle">ðŸŒ“</button>
    </div>

    <div class="container">
        <h1>PDF Form Sorter</h1>
        
        <div class="phase-selector">
            <button class="phase-btn active" id="btnPhase1">1. Analyse & Export</button>
            <button class="phase-btn" id="btnPhase2">2. Move via CSV</button>
        </div>

        <!-- Phase 1: Analyse -->
        <div id="phase1-container">
            <div class="button-container">
                <button id="selectSourceBtn" class="button btn-secondary">Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay" class="status-box">No folder selected</div>

            <div style="text-align:center; margin-bottom:15px;">
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="subfolders" checked> Scan Subfolders Only
                </label>
                <label style="margin-right:15px; cursor:pointer;">
                    <input type="radio" name="scanMode" value="root"> Scan Root Only
                </label>
                <label style="cursor:pointer;">
                    <input type="radio" name="scanMode" value="both"> Scan Both
                </label>
            </div>

            <div class="button-container">
                <button id="analyseBtn" class="button btn-primary" disabled>Analyse PDFs</button>
                <button id="stopAnalyseBtn" class="button btn-warning" style="display:none;">Stop Analysis</button>
                <button id="resetBtn1" class="button btn-danger">Reset</button>
            </div>

            <div id="loading1" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Processing..." width="40">
                <p id="loadingText1">Scanning...</p>
            </div>

            <div id="resultsArea" class="results-section">
                <div class="tab-container">
                    <button id="tabBtnA" class="tab-btn active" onclick="showTab('A')">Folder A (Non-Editable) <span id="countA">0</span></button>
                    <button id="tabBtnB" class="tab-btn" onclick="showTab('B')">Folder B (Office Use: tickable) <span id="countB">0</span></button>
                    <button id="tabBtnC" class="tab-btn" onclick="showTab('C')">Folder C (Office Use: not tickable) <span id="countC">0</span></button>
                </div>

                <div id="listA" class="file-list"></div>
                <div id="listB" class="file-list" style="display:none"></div>
                <div id="listC" class="file-list" style="display:none"></div>

                <div class="button-container">
                    <button id="downloadCsvBtnA" class="button btn-danger" style="display:none;">Download Category A CSV</button>
                    <button id="downloadCsvBtnB" class="button btn-primary" style="display:none;">Download Category B CSV</button>
                    <button id="downloadCsvBtnC" class="button btn-warning" style="display:none;">Download Category C CSV</button>
                </div>
                
                <div class="button-container" style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
                    <button id="proceedToMoveBtn" class="button btn-primary" style="display:none; font-size: 1rem; padding: 12px 24px;">
                        Proceed to Move â†’
                    </button>
                </div>
            </div>
        </div>

        <!-- Phase 2: Move -->
        <div id="phase2-container">
            <p style="text-align:center; color:var(--text-secondary); margin-bottom:20px;">
                Upload CSVs for the categories you wish to process. You can process one, two, or all three.
            </p>

            <div class="button-container">
                <button id="selectSourceBtn2" class="button btn-secondary">1. Select Source Folder</button>
            </div>
            <div id="sourcePathDisplay2" class="status-box">No source folder selected</div>

            <!-- Single Destination Folder Picker -->
            <div class="button-container" style="margin-top: 15px;">
                <button id="selectDestRootBtn" class="button btn-primary" disabled>2. Select Destination Folder</button>
                <select id="companionConflictSelect" class="button" style="background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);" disabled>
                    <option value="ask">If companion exists: Ask</option>
                    <option value="overwrite">If companion exists: Overwrite</option>
                    <option value="skip">If companion exists: Skip</option>
                </select>
            </div>
            <div id="destRootPathDisplay" class="status-box">No destination folder selected</div>
            <div id="destSubfoldersInfo" class="status-box" style="display:none; font-size: 0.85em; color: var(--text-secondary);">
                Will create: <strong>Non-Editable/</strong>, <strong>Office Use Tickable/</strong>, <strong>Office Use Not Tickable/</strong>, <strong>Companions/</strong> (if needed)
            </div>

            <style>
                .move-row {
                    display: grid;
                    grid-template-columns: 1fr 1fr; /* Two columns: Category info + CSV */
                    gap: 20px;
                    align-items: start; 
                    background: rgba(255,255,255,0.05);
                    padding: 25px;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    margin-bottom: 15px;
                }
                /* Hide old destination column */
                .move-row > div:nth-child(3) {
                    display: none;
                }
                
                /* Style for the separated tick container to merge with Row B */
                .tick-row-full {
                    background: rgba(255,255,255,0.05);
                    border: 1px solid var(--border-color);
                    border-top: none; /* Visually merge with top row */
                    border-radius: 0 0 8px 8px;
                    padding: 15px 25px;
                    margin-bottom: 15px;
                    margin-top: -15px; /* Pull up to connect */
                    width: 100%;
                    box-sizing: border-box;
                }
                
                /* Special handling for Row B to connect to ticks */
                #rowB {
                    margin-bottom: 0;
                    border-radius: 8px 8px 0 0;
                    border-bottom: none; 
                }
                
                /* Hide tick row when parent is collapsed */
                #rowB.collapsed + .tick-row-full {
                    display: none;
                }

                /* UNIFORM BUTTON SIZING */
                #lblCsvA, #lblCsvB, #lblCsvC {
                    width: 100%;
                    display: block;
                    box-sizing: border-box;
                    text-align: center;
                    margin: 0;
                    min-width: 0;
                }
                .move-row h3 {
                    margin: 0;
                    font-size: 1rem;
                    border: none;
                    text-align: left;
                }
                /* Flex column for vertical rhythm in each cell */
                .move-row > div {
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                }
                .file-status { font-size: 0.8rem; color: var(--text-secondary); margin-top: 5px; }
                .tick-options {
                    margin-top: 15px;
                    font-size: 0.85rem;
                    background: rgba(0,0,0,0.05);
                    padding: 10px;
                    border-radius: 6px;
                    width: 100%; /* Ensure full width */
                    box-sizing: border-box;
                }
                .tick-options strong {
                    grid-column: 1 / -1; /* Span full width */
                    margin-bottom: 5px;
                    display: block;
                }
                .tick-options label {
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    cursor: pointer;
                    padding: 4px;
                    border-radius: 4px;
                }
                .tick-options label:hover {
                    background: rgba(0,0,0,0.05);
                }
                
                /* Force Tick Option Labels to grow */
                #containerTicksB {
                    display: flex;
                    width: 100%;
                    gap: 10px;
                    margin-top: 10px;
                }

                #containerTicksB label {
                    flex: 1 0 0;           /* Grow equally, ignore content size */
                    width: 100%;           /* Ensure it tries to fill */
                    display: flex;
                    justify-content: center; 
                    align-items: center;
                    border: 1px solid rgba(0,0,0,0.1); 
                    padding: 10px 5px;
                    border-radius: 4px;
                    text-align: center;
                    background: rgba(255,255,255,0.5);
                    white-space: nowrap;
                    cursor: pointer;
                    font-weight: bold;
                }

                /* Remove margin-top from separated container ticks to fit nicely */
                .tick-row-full .tick-options {
                    margin-top: 0;
                    background: transparent; /* Let parent background show */
                    padding: 0;
                }

                .copy-option {
                    margin-top: 5px;
                    font-size: 0.9rem;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    cursor: pointer;
                    opacity: 0.9;
                }

                /* Minimizing Styles */
                .move-row { transition: all 0.3s ease; }
                .move-row.collapsed {
                    grid-template-columns: 1fr; /* Single full-width column */
                    padding: 10px 25px;
                    gap: 0;
                }
                .move-row.collapsed > div:nth-child(2),
                .move-row.collapsed > div:nth-child(3) {
                    display: none;
                }
                .move-row.collapsed .copy-option {
                    display: none;
                }
                /* Improved Minimize Styles */
                .move-row-header {
                    display: flex;
                    align-items: center;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 4px;
                    margin-bottom: 5px;
                }
                .move-row-header:hover {
                    background-color: rgba(0,0,0,0.03);
                }
                .toggle-icon {
                    margin-right: 8px;
                    font-size: 0.8rem;
                    transition: transform 0.3s ease;
                    display: inline-block;
                    color: var(--text-secondary);
                }
                /* Rotate icon when collapsed (point right) */
                .move-row.collapsed .toggle-icon {
                    transform: rotate(-90deg);
                }

                /* Responsive Design */
                @media (max-width: 900px) {
                    .move-row {
                        grid-template-columns: 1fr !important;
                        gap: 15px;
                    }
                    /* Ensure tick options wrap nicely on smaller screens */
                    .tick-options {
                        flex-wrap: wrap;
                    }
                    #containerTicksB {
                        flex-wrap: wrap;
                    }
                }
            </style>

            <div style="margin-top:20px;">
                <!-- Row A -->
                <div class="move-row" id="rowA">
                    <div>
                        <div class="move-row-header" onclick="toggleRow('rowA')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-a" style="border:none; margin:0;">Folder A<br><small>(Non-Editable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeA" checked disabled> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvA" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (A)
                            <input type="file" id="csvInputA" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayA" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestA" class="button btn-danger" style="width:100%; font-size:0.8rem;" disabled>Select Folder A</button>
                        <div id="pathDestA" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Row B -->
                <div class="move-row" id="rowB">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowB')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-b" style="border:none; margin:0;">Folder B<br><small>(Office Use: tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeB" checked disabled> Copy Only</label>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvB" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (B)
                            <input type="file" id="csvInputB" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayB" class="file-status">No CSV loaded</div>
                    </div>
                    <div>
                        <button id="btnDestB" class="button btn-primary" style="width:100%; font-size:0.8rem;" disabled>Select Folder B</button>
                        <div id="pathDestB" class="file-status">Not Selected</div>
                    </div>
                </div>

                <!-- Extracted Tick Options for Row B -->
                <div class="tick-row-full" id="rowB-ticks">
                    <div class="tick-options">
                        <!-- Mode Selector -->
                        <div style="margin-bottom:10px; display:flex; flex-wrap:wrap; gap:15px; font-size:0.9rem; border-bottom:1px solid rgba(0,0,0,0.1); padding-bottom:10px; width:100%; justify-content:space-between;">
                            <label style="cursor:pointer; color:var(--text-primary);">
                                <input type="radio" name="tickMode" value="retain" checked disabled> Retain Original
                            </label>
                            <label style="cursor:pointer; color:var(--button-danger);">
                                <input type="radio" name="tickMode" value="force" disabled> Force Selection
                            </label>
                            <label style="cursor:pointer; color:var(--button-primary);">
                                <input type="radio" name="tickMode" value="add" disabled> Add Selection
                            </label>
                        </div>

                        <!-- Tick Container -->
                        <div id="containerTicksB" style="display:flex; gap:15px; opacity:0.5; pointer-events:none; align-items:center; flex-wrap:wrap; width:100%;">
                            <label><input type="checkbox" class="tick-opt-b" value="0"> adr</label>
                            <label><input type="checkbox" class="tick-opt-b" value="1"> brg</label>
                            <label><input type="checkbox" class="tick-opt-b" value="2"> cmp</label>
                            <label><input type="checkbox" class="tick-opt-b" value="3" checked> dta</label>
                            <label><input type="checkbox" class="tick-opt-b" value="4"> phn</label>
                            <label><input type="checkbox" class="tick-opt-b" value="5"> oth</label>
                        </div>
                    </div>
                </div>

                <!-- Row C -->
                <div class="move-row" id="rowC">
                    <div>
                         <div class="move-row-header" onclick="toggleRow('rowC')">
                            <span class="toggle-icon">â–¼</span>
                            <h3 class="cat-c" style="border:none; margin:0;">Folder C<br><small>(Office Use: not tickable)</small></h3>
                        </div>
                        <label class="copy-option"><input type="checkbox" id="copyModeC" checked disabled> Copy Only</label>
                        <!-- Repair Template Toggle -->
                        <div style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
                            <label class="copy-option" title="Injects editable checkboxes from a template file">
                                <input type="checkbox" id="repairModeC" disabled> Repair Checkboxes
                            </label>
                        </div>
                    </div>
                    <div>
                        <label class="button btn-secondary" id="lblCsvC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.5; pointer-events:none;">
                            Select CSV (C)
                            <input type="file" id="csvInputC" accept=".csv" style="display:none" disabled>
                        </label>
                        <div id="csvDisplayC" class="file-status">No CSV loaded</div>
                        
                        <!-- Template Input -->
                        <div id="repairTemplateContainer" style="display:none; margin-top:10px;">
                            <label class="button btn-warning" id="lblTemplateC" style="display:block; text-align:center; font-size:0.8rem; opacity:0.8;">
                                Select Template PDF
                                <input type="file" id="templateInputC" accept=".pdf" style="display:none">
                            </label>
                            <div id="templateDisplayC" class="file-status">No Template loaded</div>
                        </div>
                    </div>
                    <div>
                        <button id="btnDestC" class="button btn-warning" style="width:100%; font-size:0.8rem;" disabled>Select Folder C</button>
                        <div id="pathDestC" class="file-status">Not Selected</div>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                    <input type="checkbox" id="generateSummaryCheckbox" checked>
                    Generate Summary CSV Report
                </label>
            </div>

            <div class="button-container">
                <button id="executeMoveBtn" class="button btn-primary" disabled>Execute Move</button>
                <button id="stopMoveBtn" class="button btn-warning" style="display:none;">Stop Move</button>
                <button id="resetBtn2" class="button btn-danger">Reset</button>
            </div>

             <div id="loading2" class="loading">
                <img src="https://i.gifer.com/ZZ5H.gif" alt="Moving..." width="40">
                <p id="loadingText2">Moving files...</p>
            </div>

            <div id="moveResultsArea" class="results-section" style="display:none; margin-top:20px;">
                <div class="tab-container">
                    <button id="logTabBtnA" class="tab-btn active" onclick="showLogTab('A')">Folder A (Non-Editable) <span id="logCountA">0</span></button>
                    <button id="logTabBtnB" class="tab-btn" onclick="showLogTab('B')">Folder B (Office Use: tickable) <span id="logCountB">0</span></button>
                    <button id="logTabBtnC" class="tab-btn" onclick="showLogTab('C')">Folder C (Office Use: not tickable) <span id="logCountC">0</span></button>
                    <button id="logTabBtnCompanion" class="tab-btn" onclick="showLogTab('Companion')">Companions <span id="logCountCompanion">0</span></button>
                </div>

                <div id="moveListA" class="file-list"></div>
                <div id="moveListB" class="file-list" style="display:none"></div>
                <div id="moveListC" class="file-list" style="display:none"></div>
                <div id="moveListCompanion" class="file-list" style="display:none"></div>
            </div>
        </div>

        <div id="processingTimeContainer" class="container" style="display: none; margin-top: 20px;">
             <p id="processingTime" class="status-message">Total processing time: <span id="time"></span></p>
        </div>

    </div>

    <script>
        // --- State Management ---
        let sourceDirHandle = null;
        let allFiles = []; // { name, path, handle, parentHandle, category, reason }
        
        // Phase 2 State
        let csvDataStore = { A: null, B: null, C: null };
        let destHandles = { A: null, B: null, C: null }; // Auto-populated from destRootHandle
        let destRootHandle = null; // Single destination root
        let logCounts = { A: 0, B: 0, C: 0, Companion: 0 }; // Track move counts
        let sourceDirHandle2 = null;
        
        // Companion Files State
        let companionDestHandle = null; // Auto-populated from destRootHandle
        let companionConflictMode = 'ask'; // 'overwrite' | 'skip' | 'ask'
        let processedCompanionFolders = new Set(); // Track folders already processed for companions
        
        // Repair Template State
        let repairTemplateBytes = null;
        let repairWidgetCoords = null; // [{x,y,w,h,name}, ...]

        let isProcessing = false; // Global stop flag

        // --- Session Persistence ---
        function saveSessionToStorage() {
            if (allFiles.length === 0) return;
            
            // Save analysis results (without file handles - those can't be serialized)
            const sessionData = {
                files: allFiles.map(f => ({
                    name: f.name,
                    relativePath: f.relativePath,
                    category: f.category,
                    reason: f.reason
                })),
                sourceFolderName: sourceDirHandle ? sourceDirHandle.name : null,
                timestamp: Date.now()
            };
            
            localStorage.setItem('pdfSorterSession', JSON.stringify(sessionData));
        }
        
        function loadSessionFromStorage() {
            const saved = localStorage.getItem('pdfSorterSession');
            if (!saved) return null;
            
            try {
                const sessionData = JSON.parse(saved);
                // Check if session is less than 24 hours old
                if (Date.now() - sessionData.timestamp > 24 * 60 * 60 * 1000) {
                    localStorage.removeItem('pdfSorterSession');
                    return null;
                }
                return sessionData;
            } catch (e) {
                return null;
            }
        }
        
        function clearSession() {
            localStorage.removeItem('pdfSorterSession');
        }
        
        // --- UI Toggles ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        });
        if (localStorage.getItem('darkMode') === 'enabled') document.documentElement.classList.add('dark-mode');

        // Phase Switching
        document.getElementById('btnPhase1').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'block';
            document.getElementById('phase2-container').style.display = 'none';
            document.getElementById('btnPhase1').classList.add('active');
            document.getElementById('btnPhase2').classList.remove('active');
        });
        document.getElementById('btnPhase2').addEventListener('click', () => {
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
            
            // Auto-inherit source folder from Phase 1
            if (sourceDirHandle && !sourceDirHandle2) {
                sourceDirHandle2 = sourceDirHandle;
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name} (from Phase 1)`;
                
                // Enable CSV Inputs
                ['A', 'B', 'C'].forEach(cat => {
                    const lbl = document.getElementById(`lblCsv${cat}`);
                    const inp = document.getElementById(`csvInput${cat}`);
                    if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                    if(inp) { inp.disabled = false; }
                });
                
                // Enable Destination Folder picker
                document.getElementById('selectDestRootBtn').disabled = false;
                document.getElementById('companionConflictSelect').disabled = false;
                
                // Enable Controls
                setPhase2ControlsState(true);
                checkMoveReady();
            }
            
            // Auto-populate csvDataStore from allFiles if available
            if (allFiles.length > 0 && !csvDataStore.A && !csvDataStore.B && !csvDataStore.C) {
                const groups = { A: [], B: [], C: [] };
                allFiles.forEach(f => {
                    const lastSlashIndex = f.relativePath.lastIndexOf('/');
                    let dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';
                    if (sourceDirHandle) {
                        dirPath = dirPath ? `${sourceDirHandle.name}/${dirPath}` : sourceDirHandle.name;
                    }
                    groups[f.category].push({
                        path: dirPath,
                        name: f.name,
                        category: f.category,
                        reason: f.reason
                    });
                });
                csvDataStore.A = groups.A.length > 0 ? groups.A : null;
                csvDataStore.B = groups.B.length > 0 ? groups.B : null;
                csvDataStore.C = groups.C.length > 0 ? groups.C : null;
                
                // Update CSV displays
                ['A', 'B', 'C'].forEach(cat => {
                    const data = csvDataStore[cat];
                    const display = document.getElementById(`csvDisplay${cat}`);
                    if (data) {
                        display.textContent = `From Analysis (${data.length} files)`;
                        display.style.color = 'var(--button-primary)';
                    }
                });
                
                checkMoveReady();
            }
        });

        // --- Phase 1: Analysis Logic ---

        document.getElementById('selectSourceBtn').addEventListener('click', async () => {
            try {
                sourceDirHandle = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay').textContent = `Selected: ${sourceDirHandle.name}`;
                document.getElementById('analyseBtn').disabled = false;
            } catch (err) { console.error(err); }
        });

        document.getElementById('analyseBtn').addEventListener('click', async () => {
            if (!sourceDirHandle) return;
            
            const loading = document.getElementById('loading1');
            const txt = document.getElementById('loadingText1');
            const stopBtn = document.getElementById('stopAnalyseBtn');
            const analyseBtn = document.getElementById('analyseBtn');
            const timeContainer = document.getElementById('processingTimeContainer');
            
            loading.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            timeContainer.style.display = 'none';
            analyseBtn.disabled = true; // Prevent double click
            isProcessing = true;
            
            allFiles = [];
            resetLists();
            
            const startTime = performance.now();

            try {
                txt.textContent = "Scanning folders...";
                // Get selected scan mode
                const mode = document.querySelector('input[name="scanMode"]:checked').value;
                
                const filesToProcess = await scanForPdfsConcurrent(sourceDirHandle, mode);
                
                let processedCount = 0;
                const total = filesToProcess.length;
                
                // Helper for Dynamic Concurrency Pool
                async function runConcurrentPool(items, limit, taskFn) {
                    const results = [];
                    const executing = new Set();
                    
                    let lastUpdate = 0;

                    for (const item of items) {
                        if (!isProcessing) break;

                        const p = taskFn(item).then(res => {
                            executing.delete(p);
                            processedCount++;
                            
                            // Throttle UI updates to every 100ms
                            const now = Date.now();
                            if (now - lastUpdate > 100) {
                                lastUpdate = now;
                                requestAnimationFrame(() => {
                                    txt.textContent = `Analyzing ${processedCount}/${total}`;
                                });
                            }
                            
                            return res;
                        });
                        
                        results.push(p);
                        executing.add(p);
                        
                        if (executing.size >= limit) {
                            await Promise.race(executing);
                        }
                    }
                    return Promise.all(results);
                }

                const CONCURRENCY_LIMIT = 8; // Active workers
                const results = await runConcurrentPool(filesToProcess, CONCURRENCY_LIMIT, analysePdf);
                
                // Filter and store valid results
                results.forEach(r => {
                    if (r) allFiles.push(r);
                });

                displayResults();
                
                const endTime = performance.now();
                displayProcessingTime(startTime, endTime);
                
                // Save session to localStorage
                saveSessionToStorage();

            } catch (error) {
                alert("Error during analysis: " + error.message);
                console.error(error);
            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                analyseBtn.disabled = false;
            }
        });
        
        document.getElementById('stopAnalyseBtn').addEventListener('click', () => {
            isProcessing = false;
            document.getElementById('loadingText1').textContent = "Stopping...";
        });

        // Concurrent Scan for KA*.pdf
        async function scanForPdfsConcurrent(dirHandle, mode = 'subfolders') {
            const results = [];
            const kaPattern = /^KA\d{8}.*\.pdf$/i;
            const queue = [{ handle: dirHandle, path: '', depth: 0 }];
            const MAX_CONCURRENT_DIRS = 8; // Chrome typically handles this well

            async function processDirectory(item) {
                const { handle, path, depth } = item;
                const subDirs = [];
                
                try {
                    for await (const entry of handle.values()) {
                         // Check stop flag
                        if (!isProcessing) return;

                        if (entry.kind === 'directory') {
                             // Logic: Recurse if mode is 'subfolders' or 'both'.
                            // Also, if mode is 'root', we STOP at depth 0.
                            if (mode !== 'root') {
                                 const subPath = path ? `${path}/${entry.name}` : entry.name;
                                 subDirs.push({ 
                                     handle: entry, 
                                     path: subPath, 
                                     depth: depth + 1 
                                 });
                            }
                        } else if (entry.kind === 'file') {
                            // Logic:
                            // If mode 'subfolders': Process only if depth > 0
                            // If mode 'root': Process only if depth == 0
                            // If mode 'both': Process all
                            let shouldProcess = false;
                            if (mode === 'both') shouldProcess = true;
                            else if (mode === 'root' && depth === 0) shouldProcess = true;
                            else if (mode === 'subfolders' && depth > 0) shouldProcess = true;

                            if (shouldProcess && kaPattern.test(entry.name)) {
                                results.push({
                                    name: entry.name,
                                    handle: entry,
                                    parentHandle: handle,
                                    relativePath: path ? `${path}/${entry.name}` : entry.name
                                });
                            }
                        }
                    }
                } catch (e) {
                    console.warn(`Error reading ${handle.name}:`, e);
                }
                
                return subDirs;
            }

            while (queue.length > 0 && isProcessing) {
                const batch = queue.splice(0, MAX_CONCURRENT_DIRS);
                const batchResults = await Promise.all(batch.map(item => processDirectory(item)));
                
                // Add found subdirectories to queue
                batchResults.forEach(subDirs => {
                    if(subDirs) queue.push(...subDirs);
                });
            }

            return results;
        }

        function displayProcessingTime(startTime, endTime) {
            const totalTimeInSeconds = (endTime - startTime) / 1000;
            const hours = Math.floor(totalTimeInSeconds / 3600);
            const minutes = Math.floor((totalTimeInSeconds % 3600) / 60);
            const seconds = (totalTimeInSeconds % 60).toFixed(2);

            const timeSpan = document.getElementById('time');
            timeSpan.textContent = `${hours > 0 ? hours + 'h ' : ''}${minutes > 0 ? minutes + 'm ' : ''}${seconds}s`;
            document.getElementById('processingTimeContainer').style.display = 'block';
        }

        // Core Analysis Logic
        async function analysePdf(fileObj) {
            // 1. Start: Default to Category 'A' (Non-Editable)
            // This ensures that any error, missing fields, or locked status defaults here.
            const res = { ...fileObj, category: 'A', reason: 'Default / Error / Non-Editable' };
            let pdf = null;

            try {
                const fileData = await fileObj.handle.getFile();
                const arrayBuffer = await fileData.arrayBuffer();

                // Load PDF
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                pdf = await loadingTask.promise;

                // --- CHECK 1: Page 1 Analysis (Is it Editable?) ---
                const page1 = await pdf.getPage(1);
                
                // Optional: Check Header (to ensure it's the right form type)
                const textContent1 = await page1.getTextContent();
                const page1Text = textContent1.items.map(item => item.str).join(' ');
                if (!page1Text.toLowerCase().includes("annual enterprise survey")) {
                     return { ...res, reason: 'Non-Editable' }; // Retain A
                }

                const p1Anns = await page1.getAnnotations();
                const p1Widgets = p1Anns.filter(a => a.subtype === 'Widget');

                // If no widgets on Page 1 -> Not editable form -> Stay A
                if (p1Widgets.length === 0) {
                    return { ...res, reason: 'No Form Fields on Page 1' }; // Retain A
                }

                // Check for Locked Fields on Page 1
                let p1EditableCount = 0;
                for (const w of p1Widgets) {
                    // Check readOnly flag or FieldFlags bit 1 (ReadOnly)
                    const isLocked = w.readOnly || (w.fieldFlags & 1) === 1;
                    if (!isLocked) {
                        p1EditableCount++;
                    }
                }

                // If NO field on Page 1 is editable -> Treat as Non-Editable -> Stay A
                // This allows forms with mixed locked/unlocked fields (like pre-filled ID) to pass.
                if (p1EditableCount === 0) {
                    return { ...res, reason: `Non-Editable (Page 1 has 0 editable fields)` }; // Retain A
                }

                // --- If we are here, Page 1 is Clean & Editable ---
                // Now we determine if it goes to B or C based on "Office Use" section.

                // --- CHECK 2: Office Use Section (Last Page) ---
                const lastPage = await pdf.getPage(pdf.numPages);
                const lastPageText = await lastPage.getTextContent();
                
                // Find "Office use" text
                const officeUseItem = lastPageText.items.find(item => 
                    item.str.toLowerCase().includes("office use") || 
                    item.str.toLowerCase().includes("office use:")
                );

                if (!officeUseItem) {
                    // If Office Use section is missing completely -> Treat as "Widgets Missing" -> Stay A
                    // (Or arguably C, but plan says 'Widgets missing -> Do nothing (Retain A)')
                    return { ...res, reason: 'Missing "Office use:" section' }; // Retain A
                }

                const textY = officeUseItem.transform[5]; 
                const anns = await lastPage.getAnnotations();
                
                // Find checkboxes physically below the "Office use" text
                // We use a loose threshold (+20) to handle minor alignment issues, 
                // but STRICTLY exclude boxes significantly higher up (user boxes).
                const relevantBoxes = anns.filter(a => 
                    a.subtype === 'Widget' && 
                    a.fieldType === 'Btn' && 
                    !a.radioButton &&
                    a.rect[1] < (textY + 20) // Must be below or just inline with the text
                );

                if (relevantBoxes.length === 0) {
                    // If text is found but no boxes in the office section, it's effectively "Not Tickable" -> C
                    return { ...res, category: 'C', reason: 'No checkboxes found in Office Use section' }; 
                }

                // Check if these specific OFFICE boxes are Editable
                let hasEditableOfficeBox = false;
                for (const box of relevantBoxes) {
                    const isReadOnly = box.readOnly || (box.fieldFlags & 1) === 1;
                    if (!isReadOnly) {
                        hasEditableOfficeBox = true;
                        break;
                    }
                }

                // --- FINAL OUTCOME ---
                if (hasEditableOfficeBox) {
                    // Page 1 Editable AND Office Use Tickable -> Folder B
                    return { ...res, category: 'B', reason: 'Page 1 Editable & Office Use Tickable' };
                } else {
                    // Page 1 Editable BUT Office Use Locked -> Folder C
                    return { ...res, category: 'C', reason: 'Page 1 Editable but Office Use Locked' };
                }

            } catch (err) {
                // Any error -> Stay A
                if (err.name === 'PasswordException') {
                    return { ...res, reason: 'Encrypted / Password Protected' };
                }
                return { ...res, reason: 'Error: ' + err.message };
            } finally {
                // CRITICAL MEMORY CLEANUP
                if (pdf) {
                    await pdf.destroy();
                }
            }
        }

        // Display Functions
        function resetLists() {
            document.getElementById('listA').innerHTML = '';
            document.getElementById('listB').innerHTML = '';
            document.getElementById('listC').innerHTML = '';
            document.getElementById('resultsArea').style.display = 'none';
        }

        function displayResults() {
            document.getElementById('resultsArea').style.display = 'block';
            
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => groups[f.category].push(f));

            document.getElementById('countA').textContent = groups.A.length;
            document.getElementById('countB').textContent = groups.B.length;
            document.getElementById('countC').textContent = groups.C.length;

            renderList('listA', groups.A);
            renderList('listB', groups.B);
            renderList('listC', groups.C);

            // Fix: Initialize view state to match the default active tab (A)
            // This ensures the correct Download button is visible immediately.
            showTab('A');
            
            // Show "Proceed to Move" button if there are files to process
            if (allFiles.length > 0) {
                document.getElementById('proceedToMoveBtn').style.display = 'inline-block';
            }
        }

        function renderList(id, files) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            files.forEach(f => {
                const div = document.createElement('div');
                div.className = 'file-item';
                div.title = "Ctrl+Click to open PDF in new tab"; // Hover Tooltip
                div.innerHTML = `
                    <span>${f.relativePath}</span>
                    <span class="reason-tag">${f.reason}</span>
                `;
                
                // Click to open
                div.addEventListener('click', async (e) => {
                    if (!e.ctrlKey && !e.metaKey) return; // specific user request
                    
                    // Add visited state
                    div.classList.add('visited');
                    
                    try {
                        const file = await f.handle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                        // Note: Revoke logic is tricky with open-in-new-tab, browser handles cleanup usually on close
                    } catch(e) {
                        alert("Could not open file: " + e.message);
                    }
                });

                container.appendChild(div);
            });
        }

        window.showTab = function(cat) {
            ['A', 'B', 'C'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`list${c}`).style.display = isMatch ? 'block' : 'none';
                // Show relevant download button
                document.getElementById(`downloadCsvBtn${c}`).style.display = isMatch ? 'inline-block' : 'none';
            });
            // Simple generic tab toggle
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            
            // Fix: Explicitly target the correct button via ID to avoid selector errors
            const activeBtn = document.getElementById(`tabBtn${cat}`);
            if (activeBtn) activeBtn.classList.add('active');
        };

        // CSV Export - Split into 3 functions
        function downloadCsvForCategory(cat) {
            const files = allFiles.filter(f => f.category === cat);
            if (files.length === 0) {
                alert(`No files in Category ${cat} to export.`);
                return;
            }
            
            let csv = "FilePath,FileName,Category,Reason,MoveStatus\n";
            files.forEach(f => {
                // Remove filename from path (get directory only)
                // relativePath is "Subfolder/File.pdf" -> "Subfolder"
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                let dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';

                // Prepend the root folder name to give context
                if (sourceDirHandle) {
                    dirPath = dirPath ? `${sourceDirHandle.name}/${dirPath}` : sourceDirHandle.name;
                }
                // Cleanup any trailing slashes if logic above left them (e.g. "Root/")
                if (dirPath.endsWith('/')) dirPath = dirPath.slice(0, -1);

                const path = `"${dirPath}"`; // Directory Only
                const reason = `"${f.reason}"`;
                csv += `${path},${f.name},${f.category},${reason},Pending\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pdf-analysis-${cat}-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
            a.click();
        }

        document.getElementById('downloadCsvBtnA').addEventListener('click', () => downloadCsvForCategory('A'));
        document.getElementById('downloadCsvBtnB').addEventListener('click', () => downloadCsvForCategory('B'));
        document.getElementById('downloadCsvBtnC').addEventListener('click', () => downloadCsvForCategory('C'));

        // Proceed to Move - Direct Phase 1 â†’ Phase 2 Flow
        document.getElementById('proceedToMoveBtn').addEventListener('click', () => {
            if (allFiles.length === 0) return;
            
            // Group files by category and convert to CSV format
            const groups = { A: [], B: [], C: [] };
            allFiles.forEach(f => {
                // Convert to CSV row format matching parseCsv output
                const lastSlashIndex = f.relativePath.lastIndexOf('/');
                let dirPath = lastSlashIndex > -1 ? f.relativePath.substring(0, lastSlashIndex) : '';
                if (sourceDirHandle) {
                    dirPath = dirPath ? `${sourceDirHandle.name}/${dirPath}` : sourceDirHandle.name;
                }
                
                groups[f.category].push({
                    path: dirPath,
                    name: f.name,
                    category: f.category,
                    reason: f.reason
                });
            });
            
            // Populate csvDataStore
            csvDataStore.A = groups.A.length > 0 ? groups.A : null;
            csvDataStore.B = groups.B.length > 0 ? groups.B : null;
            csvDataStore.C = groups.C.length > 0 ? groups.C : null;
            
            // Copy source folder to Phase 2
            sourceDirHandle2 = sourceDirHandle;
            
            // Switch to Phase 2
            document.getElementById('phase1-container').style.display = 'none';
            document.getElementById('phase2-container').style.display = 'block';
            document.getElementById('btnPhase1').classList.remove('active');
            document.getElementById('btnPhase2').classList.add('active');
            
            // Update Phase 2 UI
            document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name} (from Phase 1)`;
            
            // Update CSV displays to show loaded counts
            ['A', 'B', 'C'].forEach(cat => {
                const data = csvDataStore[cat];
                const display = document.getElementById(`csvDisplay${cat}`);
                const lbl = document.getElementById(`lblCsv${cat}`);
                const inp = document.getElementById(`csvInput${cat}`);
                
                if (data) {
                    display.textContent = `From Analysis (${data.length} files)`;
                    display.style.color = 'var(--button-primary)';
                } else {
                    display.textContent = 'No files in this category';
                }
                
                // Enable CSV inputs for override
                if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                if(inp) { inp.disabled = false; }
            });
            
            // Enable controls
            document.getElementById('selectDestRootBtn').disabled = false;
            document.getElementById('companionConflictSelect').disabled = false;
            setPhase2ControlsState(true);
            checkMoveReady();
        });

        document.getElementById('resetBtn1').addEventListener('click', () => {
            allFiles = [];
            resetLists();
            document.getElementById('sourcePathDisplay').textContent = 'No folder selected';
            document.getElementById('proceedToMoveBtn').style.display = 'none';
            sourceDirHandle = null;
            document.getElementById('analyseBtn').disabled = true;
            clearSession(); // Clear saved session
        });


        // --- Phase 2: Move Logic ---
        
        function setPhase2ControlsState(enabled) {
             // Copy Checkboxes
            ['A','B','C'].forEach(c => {
                const el = document.getElementById(`copyMode${c}`);
                if (el) el.disabled = !enabled;
            });
            
            // Tick Mode Radios
            document.querySelectorAll('input[name="tickMode"]').forEach(r => r.disabled = !enabled);
            
            // Tick Container: If disabled, force visual disable. If enabled, let logic decide based on radio.
            const container = document.getElementById('containerTicksB');
            if (!enabled) {
                container.style.opacity = '0.5';
                container.style.pointerEvents = 'none';
            } else {
                // If enabling, restore state based on currently checked radio
                const mode = document.querySelector('input[name="tickMode"]:checked').value;
                const isRetain = (mode === 'retain');
                if (!isRetain) {
                     container.style.opacity = '1';
                     container.style.pointerEvents = 'auto';
                }
            }
            
            // Enable Repair Checkbox if conditions met
            if (enabled) {
                checkRepairAvailability();
            }
        }

        document.getElementById('selectSourceBtn2').addEventListener('click', async () => {
             try {
                sourceDirHandle2 = await window.showDirectoryPicker();
                document.getElementById('sourcePathDisplay2').textContent = `Selected: ${sourceDirHandle2.name}`;
                
                // Enable CSV Inputs
                ['A', 'B', 'C'].forEach(cat => {
                    const lbl = document.getElementById(`lblCsv${cat}`);
                    const inp = document.getElementById(`csvInput${cat}`);
                    if(lbl) { lbl.style.opacity = '1'; lbl.style.pointerEvents = 'auto'; }
                    if(inp) { inp.disabled = false; }
                });
                
                // Enable Destination Folder picker
                document.getElementById('selectDestRootBtn').disabled = false;
                document.getElementById('companionConflictSelect').disabled = false;
                
                // Enable Controls
                setPhase2ControlsState(true);

                checkMoveReady();
            } catch (err) { console.error(err); }
        });
        
        // Single Destination Folder Picker
        document.getElementById('selectDestRootBtn').addEventListener('click', async () => {
            try {
                destRootHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                document.getElementById('destRootPathDisplay').textContent = `Selected: ${destRootHandle.name}`;
                document.getElementById('destSubfoldersInfo').style.display = 'block';
                
                // Auto-create subfolder handles (will be created on execute)
                // For now, just set destHandles and companionDestHandle to indicate destination is ready
                destHandles.A = destRootHandle;
                destHandles.B = destRootHandle;
                destHandles.C = destRootHandle;
                companionDestHandle = destRootHandle;
                
                checkMoveReady();
            } catch (err) { console.error(err); }
        });
        
        // Companion Conflict Mode
        document.getElementById('companionConflictSelect').addEventListener('change', (e) => {
            companionConflictMode = e.target.value;
        });

        document.getElementById('copyModeC').addEventListener('change', () => checkRepairAvailability());

        function checkRepairAvailability() {
            // Repair mode only available if NOT copy mode (moving implies modifying? actually copying is fine too)
            // Logic: Just needs source folder selected.
            // Update: Repair is an optional checkbox.
            const repairToggle = document.getElementById('repairModeC');
            const templateContainer = document.getElementById('repairTemplateContainer');
            
            if (sourceDirHandle2) {
                repairToggle.disabled = false;
            }
            
            if (repairToggle.checked) {
                 templateContainer.style.display = 'block';
            } else {
                 templateContainer.style.display = 'none';
            }
        }
        
        document.getElementById('repairModeC').addEventListener('change', checkRepairAvailability);

        // Template Upload Handler
        document.getElementById('templateInputC').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const buffer = await file.arrayBuffer();
                repairTemplateBytes = buffer;
                
                // Scan for coords immediately
                const pdfDoc = await PDFLib.PDFDocument.load(buffer);
                const pageCount = pdfDoc.getPageCount();
                const lastPage = pdfDoc.getPage(pageCount - 1);
                
                // Extract Checkbox Widgets from last page
                // Re-using logic similar to finding them for scanned files, but using PDF-Lib
                const form = pdfDoc.getForm();
                const fields = form.getFields();
                const checkboxes = fields.filter(f => f instanceof PDFLib.PDFCheckBox);
                
                const candidates = [];
                
                for (const box of checkboxes) {
                    const widgets = box.acroField.getWidgets();
                    for (const w of widgets) {
                        const rect = w.getRectangle();
                        const widgetDict = w.dict;
                        
                        // Extract appearance streams and characteristics for true 1:1 copy
                        candidates.push({
                             name: box.getName(),
                             x: rect.x,
                             y: rect.y,
                             w: rect.width,
                             h: rect.height,
                             // Store raw dictionaries for appearance stream copying
                             appearanceDict: widgetDict.get(PDFLib.PDFName.of('AP')),
                             mkDict: widgetDict.get(PDFLib.PDFName.of('MK')),
                             bsDict: widgetDict.get(PDFLib.PDFName.of('BS')),
                        });
                    }
                }
                
                // Sort candidates by Y (ascending) then X
                candidates.sort((a, b) => {
                     const yDiff = Math.abs(a.y - b.y);
                     if (yDiff < 10) return a.x - b.x;
                     return a.y - b.y;
                });
                
                // Filter: Take the bottom-most row (first 6 in sorted list)
                // Expecting 6: adr, brg, cmp, dta, phn, oth
                if (candidates.length >= 6) {
                     repairWidgetCoords = candidates.slice(0, 6);
                     document.getElementById('templateDisplayC').textContent = `Loaded: ${file.name} (Found ${repairWidgetCoords.length} widgets)`;
                     document.getElementById('templateDisplayC').style.color = 'var(--button-primary)';
                } else {
                     repairTemplateBytes = null;
                     repairWidgetCoords = null;
                     document.getElementById('templateDisplayC').textContent = `Error: Found only ${candidates.length} checkboxes (Need 6)`;
                     document.getElementById('templateDisplayC').style.color = 'var(--button-danger)';
                     alert("Template Invalid: Could not find 6 checkboxes on the last page.");
                }
                
            } catch (err) {
                console.error(err);
                document.getElementById('templateDisplayC').textContent = "Error reading template";
            }
        });

        // CSV Inputs Handlers (A, B, C)
        ['A', 'B', 'C'].forEach(cat => {
            document.getElementById(`csvInput${cat}`).addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const text = await file.text();
                csvDataStore[cat] = parseCsv(text);
                document.getElementById(`csvDisplay${cat}`).textContent = `${file.name} (${csvDataStore[cat].length} rows)`;
                checkMoveReady();
            });
        });

        async function pickDest(cat) {
            try {
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' }); // Request write permission upfront
                destHandles[cat] = handle;
                document.getElementById(`pathDest${cat}`).textContent = handle.name;
                checkMoveReady();
            } catch(e) { console.error(e); }
        }

        document.getElementById('btnDestA').addEventListener('click', () => pickDest('A'));
        document.getElementById('btnDestB').addEventListener('click', () => pickDest('B'));
        document.getElementById('btnDestC').addEventListener('click', () => pickDest('C'));

        // Override Checkbox Toggle - UPDATED for 3-way Radio
        document.querySelectorAll('input[name="tickMode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                const container = document.getElementById('containerTicksB');
                const isRetain = (e.target.value === 'retain');
                if (isRetain) {
                    container.style.opacity = '0.5';
                    container.style.pointerEvents = 'none';
                } else {
                    container.style.opacity = '1';
                    container.style.pointerEvents = 'auto';
                }
            });
        });

        // Update Execute Button Label based on modes
        function updateExecuteButtonLabel() {
            const copyA = document.getElementById('copyModeA').checked;
            const copyB = document.getElementById('copyModeB').checked;
            const copyC = document.getElementById('copyModeC').checked;
            
            // Count active categories?
            // Actually, we should only consider the categories that have CSVs loaded.
            // But the checkboxes are always there.
            // Let's assume the intent is based on the checked state of ALL enabled boxes.
            // But wait, if I don't upload CSV A, copyModeA is irrelevant.
            // So we should filter by 'active' rows.
            
            const hasCsvA = !!csvDataStore.A;
            const hasCsvB = !!csvDataStore.B;
            const hasCsvC = !!csvDataStore.C;
            
            let totalOps = 0;
            let moveOps = 0;
            let copyOps = 0;
            
            if (hasCsvA) { totalOps++; if (!copyA) moveOps++; else copyOps++; }
            if (hasCsvB) { totalOps++; if (!copyB) moveOps++; else copyOps++; }
            if (hasCsvC) { totalOps++; if (!copyC) moveOps++; else copyOps++; }
            
            const btn = document.getElementById('executeMoveBtn');
            
            if (totalOps === 0) {
                btn.textContent = "Execute Move"; // Default
                return;
            }
            
            if (moveOps > 0 && copyOps === 0) {
                btn.textContent = "Execute Move";
                btn.className = "button btn-danger"; // Warning color for Move
            } else if (copyOps > 0 && moveOps === 0) {
                btn.textContent = "Execute Copy";
                btn.className = "button btn-primary"; // Safe color for Copy
            } else {
                btn.textContent = "Execute Copy/Move";
                btn.className = "button btn-warning"; // Mixed
            }
        }

        ['A', 'B', 'C'].forEach(c => {
            document.getElementById(`copyMode${c}`).addEventListener('change', updateExecuteButtonLabel);
        });

        function checkMoveReady() {
            if (!sourceDirHandle2) {
                document.getElementById('executeMoveBtn').disabled = true;
                return;
            }
            
            // Check if destination is selected AND at least one category has files
            const hasAnyFiles = csvDataStore.A || csvDataStore.B || csvDataStore.C;
            const hasDestination = !!destRootHandle;

            document.getElementById('executeMoveBtn').disabled = !(hasAnyFiles && hasDestination);
            
            // Update Label
            updateExecuteButtonLabel();
        }

        function parseCsv(text) {
            const lines = text.split('\n').filter(l => l.trim());
            // Simple check to see if header exists, assuming standard format
            const startIdx = lines[0].toLowerCase().startsWith('filepath') ? 1 : 0;
            
            // Improved Regex split to handle quoted fields
            const regex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;
            
            const data = [];
            for(let i=startIdx; i<lines.length; i++) {
                const cols = lines[i].split(regex).map(s => s.replace(/^"|"$/g, '').trim());
                if(cols.length < 2) continue; // Need at least path and name
                data.push({
                    path: cols[0],
                    name: cols[1],
                    category: cols[2] || '',
                    reason: cols[3] || '' // Capture Reason (Column 4)
                });
            }
            return data;
        }

        document.getElementById('executeMoveBtn').addEventListener('click', async () => {
            const loading = document.getElementById('loading2');
            const resultsArea = document.getElementById('moveResultsArea');
            
            // Reset Logs
            ['A', 'B', 'C', 'Companion'].forEach(c => {
                document.getElementById(`moveList${c}`).innerHTML = '';
                document.getElementById(`logCount${c}`).textContent = '0';
            });
            logCounts = { A: 0, B: 0, C: 0, Companion: 0 };
            processedCompanionFolders.clear(); // Reset processed folders tracking
            
            const generateSummary = document.getElementById('generateSummaryCheckbox').checked;
            const stopBtn = document.getElementById('stopMoveBtn');
            const execBtn = document.getElementById('executeMoveBtn');
            
            // Warning Check for Move
            const copyA = document.getElementById('copyModeA').checked;
            const copyB = document.getElementById('copyModeB').checked;
            const copyC = document.getElementById('copyModeC').checked;
            const hasCsvA = !!csvDataStore.A;
            const hasCsvB = !!csvDataStore.B;
            const hasCsvC = !!csvDataStore.C;
            
            let moving = false;
            if (hasCsvA && !copyA) moving = true;
            if (hasCsvB && !copyB) moving = true;
            if (hasCsvC && !copyC) moving = true;
            
            if (moving) {
                const ok = confirm("Warning: You are about to MOVE files.\n\nThis will PERMANENTLY DELETE the original files from the source folder.\n\nAre you sure you want to continue?");
                if (!ok) return;
            }
            
            loading.style.display = 'block';
            resultsArea.style.display = 'block';
            stopBtn.style.display = 'inline-block';
            execBtn.disabled = true;
            
            // Default to showing Log A initially
            showLogTab('A');
            
            isProcessing = true;
            const loadingText2 = document.getElementById('loadingText2');
            loadingText2.textContent = "Starting..."; // Reset default text
            
            const summaryData = []; // Store for CSV export

            try {
                // Create category subfolders under destRootHandle
                const categoryFolderNames = { A: 'Non-Editable', B: 'Office Use Tickable', C: 'Office Use Not Tickable' };
                const categoryFolders = {};
                
                for (const cat of ['A', 'B', 'C']) {
                    if (csvDataStore[cat] && destRootHandle) {
                        categoryFolders[cat] = await destRootHandle.getDirectoryHandle(categoryFolderNames[cat], { create: true });
                    }
                }
                
                // Companions folder will be created lazily when first companion is found
                companionDestHandle = null;
                
                // Iterate over categories A, B, C
                for (const cat of ['A', 'B', 'C']) {
                    if (!isProcessing) break; // Stop check outer loop
                    
                    const data = csvDataStore[cat];
                    const targetFolder = categoryFolders[cat];
                    const isCopyOnly = document.getElementById(`copyMode${cat}`).checked;

                    // Skip if not configured (CSV missing or Folder missing)
                    if (!data || !targetFolder) continue;

                    // Get selected tick indices for Category B
                    let selectedTickIndices = [];
                    if (cat === 'B') {
                        const opts = document.querySelectorAll('.tick-opt-b:checked');
                        opts.forEach(opt => selectedTickIndices.push(parseInt(opt.value)));
                    }

                    for (const row of data) {
                        if (!isProcessing) {
                            logMsg(cat, "SYSTEM", "", "Process stopped by user", "orange");
                            break; // Stop check inner loop
                        }

                        const action = isCopyOnly ? "Copying" : "Moving";
                        loadingText2.textContent = `${action} ${row.name}...`;

                        const summaryRow = {
                            FileName: row.name,
                            OriginalPath: row.path,
                            Category: cat,
                            DestinationFolder: targetFolder.name,
                            Status: 'Pending',
                            Message: ''
                        };

                        // 1. Find File in Source
                        // CSV Row Path is "Subfolder" (Directory). Filename is separate.
                        let rawPath = row.path || '';
                        // Remove quotes just in case
                        rawPath = rawPath.replace(/^"|"$/g, '');
                        let pathParts = rawPath.split('/').filter(p => p);

                        // FIX: If the CSV includes the root folder name (which we added), remove it
                        // so we don't look for Root inside Root.
                        if (pathParts.length > 0 && pathParts[0] === sourceDirHandle2.name) {
                            pathParts.shift();
                        }
                        
                        pathParts.push(row.name);

                        let currentHandle = sourceDirHandle2;
                        let fileHandle = null;
                        let parentHandle = sourceDirHandle2; 

                        try {
                            // Traverse
                            for(let i=0; i<pathParts.length; i++) {
                                const part = pathParts[i];
                                if (i === pathParts.length - 1) {
                                    fileHandle = await currentHandle.getFileHandle(part);
                                } else {
                                    currentHandle = await currentHandle.getDirectoryHandle(part);
                                    parentHandle = currentHandle;
                                }
                            }
                        } catch (e) {
                            logMsg(cat, row.name, row.reason, "File Not Found in Source", 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "File Not Found in Source";
                            summaryData.push(summaryRow);
                            continue;
                        }

                        // 2. Move
                        try {
                            let fileData = await fileHandle.getFile();
                            let fileArrayBuffer = await fileData.arrayBuffer();
                            
                            // === AUTOMATED MODIFICATION FOR CATEGORY B ===
                            const tickMode = document.querySelector('input[name="tickMode"]:checked').value;
                            
                            if (cat === 'B' && tickMode !== 'retain') {
                                try {
                                    // Load with pdf-lib
                                    const pdfDoc = await PDFLib.PDFDocument.load(fileArrayBuffer);
                                    const form = pdfDoc.getForm();
                                    const fields = form.getFields();
                                    const pageCount = pdfDoc.getPageCount();

                                    // We need to find the widgets on the LAST page to sort them spatially.
                                    const checkboxes = fields.filter(f => f instanceof PDFLib.PDFCheckBox);
                                    const relevantBoxes = [];

                                    for (const box of checkboxes) {
                                        const widgets = box.acroField.getWidgets();
                                        for (const w of widgets) {
                                            const rect = w.getRectangle();
                                        }
                                    }
                                    
                                    // BETTER STRATEGY: Top-Down Traversal (Page -> Annotations -> Fields)
                                    const lastPage = pdfDoc.getPage(pageCount - 1);
                                    const lastPageAnnots = lastPage.node.Annots();
                                    const candidates = [];

                                    if (lastPageAnnots) {
                                        // Create a map of Ref -> Field for all checkboxes
                                        const refToFieldMap = new Map();
                                        
                                        for (const field of checkboxes) {
                                            if (field.ref) refToFieldMap.set(field.ref.toString(), field);
                                            const widgets = field.acroField.getWidgets();
                                            widgets.forEach(w => {
                                                if (w.ref) refToFieldMap.set(w.ref.toString(), field);
                                            });
                                        }

                                        // Traverse the page's annotations
                                        for (let i = 0; i < lastPageAnnots.size(); i++) {
                                            const annotRef = lastPageAnnots.get(i);
                                            let annotDict = null;
                                            let annotStr = null;

                                            if (annotRef instanceof PDFLib.PDFRef) {
                                                annotStr = annotRef.toString();
                                                annotDict = pdfDoc.context.lookup(annotRef);
                                            } else if (annotRef instanceof PDFLib.PDFDict) {
                                                annotDict = annotRef;
                                            }

                                            if (!annotDict) continue;

                                            const subtype = annotDict.get(PDFLib.PDFName.of('Subtype'));
                                            if (subtype !== PDFLib.PDFName.of('Widget')) continue;

                                            let matchedField = null;
                                            
                                            if (annotStr && refToFieldMap.has(annotStr)) {
                                                matchedField = refToFieldMap.get(annotStr);
                                            }
                                            
                                            if (!matchedField) {
                                                const parent = annotDict.get(PDFLib.PDFName.of('Parent'));
                                                if (parent instanceof PDFLib.PDFRef && refToFieldMap.has(parent.toString())) {
                                                    matchedField = refToFieldMap.get(parent.toString());
                                                }
                                            }

                                            if (matchedField && matchedField instanceof PDFLib.PDFCheckBox) {
                                                const rectArr = annotDict.get(PDFLib.PDFName.of('Rect'));
                                                if (rectArr && rectArr instanceof PDFLib.PDFArray) {
                                                    const x = rectArr.get(0).asNumber();
                                                    const y = rectArr.get(1).asNumber();
                                                    candidates.push({ field: matchedField, x, y });
                                                }
                                            }
                                        }
                                    }

                                    // Sort: Primary Y (Bottom-up), Secondary X (Left-Right)
                                    candidates.sort((a, b) => {
                                        const yDiff = Math.abs(a.y - b.y);
                                        if (yDiff < 10) return a.x - b.x;
                                        return a.y - b.y;
                                    });
                                    
                                    // Office Use section is at bottom (lowest Y first after sort)
                                    // Expect 6 boxes: adr(0), brg(1), cmp(2), dta(3), phn(4), oth(5)
                                    
                                    if (candidates.length >= 6) {
                                        if (Math.abs(candidates[5].y - candidates[0].y) < 20) {
                                            let tickedCount = 0;
                                            let untickedCount = 0;
                                            
                                            for (let i = 0; i < 6; i++) {
                                                if (candidates[i]) {
                                                    if (selectedTickIndices.includes(i)) {
                                                        candidates[i].field.check();
                                                        tickedCount++;
                                                    } else if (tickMode === 'force') {
                                                        candidates[i].field.uncheck();
                                                        untickedCount++;
                                                    }
                                                }
                                            }
                                            
                                            if (tickedCount > 0 || untickedCount > 0) {
                                                fileArrayBuffer = await pdfDoc.save();
                                                summaryRow.Message += ` [Updated: ${tickedCount} Checked, ${untickedCount} Unchecked]`;
                                            }
                                        } else {
                                            summaryRow.Message += " [Warning: Layout mismatch, no boxes modified]";
                                        }
                                    } else {
                                        summaryRow.Message += ` [Warning: Found only ${candidates.length} checkboxes, expected 6+]`;
                                    }
                                    
                                } catch (pdfLibErr) {
                                    console.error(pdfLibErr);
                                    summaryRow.Message += ` [Error Ticking: ${pdfLibErr.message}]`;
                                }
                            }
                            // === END CATEGORY B MODIFICATION ===
                            
                            // === AUTOMATED REPAIR FOR CATEGORY C ===
                            const repairMode = document.getElementById('repairModeC').checked;
                            if (cat === 'C' && repairMode && repairWidgetCoords) {
                                try {
                                    // Load with pdf-lib if not already loaded
                                    // Note: The 'B' block above loads it locally. We need to load it here if it wasn't loaded.
                                    // Actually, 'fileArrayBuffer' is the source.
                                    const pdfDoc = await PDFLib.PDFDocument.load(fileArrayBuffer);
                                    const pageCount = pdfDoc.getPageCount();
                                    const lastPage = pdfDoc.getPage(pageCount - 1);
                                    const form = pdfDoc.getForm();
                                    
                                    // 1. Draw White Masks over old boxes
                                    // 2. Create New Checkboxes
                                    
                                    const { width, height } = lastPage.getSize();
                                    
                                    repairWidgetCoords.forEach(coord => {
                                        // Removed Masking: We want the original underlying 3D-style box to show through.
                                        // We will place an invisible, clickable widget on top of it.
                                        
                                        // Create Checkbox with appearance streams copied from template (true 1:1 copy)
                                        try {
                                            const newBox = form.createCheckBox(coord.name);
                                            
                                            // Add to page with basic positioning
                                            newBox.addToPage(lastPage, {
                                                x: coord.x,
                                                y: coord.y,
                                                width: coord.w,
                                                height: coord.h,
                                            });
                                            
                                            // Copy appearance streams from template for true 1:1 visual match
                                            const newWidgets = newBox.acroField.getWidgets();
                                            if (newWidgets.length > 0) {
                                                const newWidgetDict = newWidgets[0].dict;
                                                
                                                // Copy AP (Appearance) dictionary - contains actual graphics
                                                if (coord.appearanceDict) {
                                                    newWidgetDict.set(PDFLib.PDFName.of('AP'), coord.appearanceDict);
                                                }
                                                
                                                // Copy MK (Appearance Characteristics) - border/background colors
                                                if (coord.mkDict) {
                                                    newWidgetDict.set(PDFLib.PDFName.of('MK'), coord.mkDict);
                                                }
                                                
                                                // Copy BS (Border Style) - border width/style
                                                if (coord.bsDict) {
                                                    newWidgetDict.set(PDFLib.PDFName.of('BS'), coord.bsDict);
                                                }
                                            }
                                        } catch (err) {
                                            // Field might already exist? If so, try to revive it?
                                            // If it exists but is broken, maybe we can't easily replace it with the same name.
                                            // Let's try a fallback name if collision.
                                            // summaryRow.Message += ` [Field ${coord.name} collision]`;
                                            // Actually, if we are repairing, maybe we should delete the old field first?
                                            // But usually C files are "Not Tickable" because fields are MISSING (just image) or Locked.
                                            
                                            // Just in case, try getting the existing field
                                            try {
                                                const existing = form.getField(coord.name);
                                                // If it exists, maybe we just unlock it and move it?
                                                // Or just ignore creating new one?
                                                // If it exists, it might be the read-only one.
                                                if (existing) {
                                                    // enableReadOnly(false)?
                                                    // existing.enableReadOnly(false); // Not direct method in all versions
                                                    // pdf-lib doesn't strictly have "enableReadOnly(false)" easy access on high level API always.
                                                    // But let's assume for now we are creating NEW ones because C usually means "Image Only".
                                                }
                                            } catch(ex) {}
                                        }
                                    });
                                    
                                    fileArrayBuffer = await pdfDoc.save();
                                    summaryRow.Message += " [Repaired]";
                                    
                                } catch (err) {
                                    console.error(err);
                                    summaryRow.Message += ` [Repair Failed: ${err.message}]`;
                                }
                            }
                            // =============================================

                            // Determine Destination Directory
                            // All categories now flatten to destination root
                            let finalDestHandle = targetFolder;

                            // Check collision
                            let newName = row.name;
                            try {
                                await finalDestHandle.getFileHandle(newName);
                                newName = newName.replace('.pdf', `_${Date.now()}.pdf`);
                            } catch(e) {}

                            const newFileHandle = await finalDestHandle.getFileHandle(newName, { create: true });
                            const writable = await newFileHandle.createWritable();
                            // Write the (potentially modified) buffer
                            await writable.write(fileArrayBuffer);
                            await writable.close();

                            if (!isCopyOnly) {
                                await parentHandle.removeEntry(fileHandle.name);
                                logMsg(cat, row.name, row.reason, "Moved", 'green', newFileHandle);
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Moved]`;
                            } else {
                                logMsg(cat, row.name, row.reason, "Copied", 'blue', newFileHandle);
                                summaryRow.Status = 'Success';
                                summaryRow.Message += ` [Copied]`;
                            }
                            
                            // === COMPANION FILE PROCESSING ===
                            // Process companion files if: companion folder selected AND folder not yet processed
                            const folderPath = pathParts.slice(0, -1).join('/'); // Get folder path without filename
                            if (destRootHandle && folderPath && !processedCompanionFolders.has(folderPath)) {
                                processedCompanionFolders.add(folderPath);
                                
                                try {
                                    const kaPattern = /^KA\d{8}.*\.pdf$/i;
                                    const companionFiles = [];
                                    
                                    // List all files in the source folder
                                    for await (const entry of parentHandle.values()) {
                                        if (entry.kind === 'file' && !kaPattern.test(entry.name)) {
                                            companionFiles.push(entry);
                                        }
                                    }
                                    
                                    if (companionFiles.length > 0) {
                                        // Lazily create Companions folder on first companion found
                                        if (!companionDestHandle) {
                                            companionDestHandle = await destRootHandle.getDirectoryHandle('Companions', { create: true });
                                        }
                                        
                                        // Create destination subfolder
                                        const folderName = pathParts.length > 1 ? pathParts[pathParts.length - 2] : pathParts[0];
                                        const companionSubFolder = await companionDestHandle.getDirectoryHandle(folderName, { create: true });
                                        
                                        for (const compFile of companionFiles) {
                                            if (!isProcessing) break;
                                            
                                            const compSummaryRow = {
                                                FileName: compFile.name,
                                                OriginalPath: folderPath,
                                                Category: 'Companion',
                                                DestinationFolder: companionDestHandle.name + '/' + folderName,
                                                Status: 'Pending',
                                                Message: ''
                                            };
                                            
                                            try {
                                                // Check if file exists in destination
                                                let shouldProcess = true;
                                                let existingHandle = null;
                                                
                                                try {
                                                    existingHandle = await companionSubFolder.getFileHandle(compFile.name);
                                                    // File exists - handle based on conflict mode
                                                    if (companionConflictMode === 'skip') {
                                                        logMsg('Companion', compFile.name, folderName, "Skipped (exists)", 'orange');
                                                        compSummaryRow.Status = 'Skipped';
                                                        compSummaryRow.Message = '[Skipped - file exists]';
                                                        shouldProcess = false;
                                                    } else if (companionConflictMode === 'ask') {
                                                        const userChoice = confirm(`Companion file "${compFile.name}" already exists in destination.\n\nOverwrite?`);
                                                        if (!userChoice) {
                                                            logMsg('Companion', compFile.name, folderName, "Skipped (user)", 'orange');
                                                            compSummaryRow.Status = 'Skipped';
                                                            compSummaryRow.Message = '[Skipped - user choice]';
                                                            shouldProcess = false;
                                                        }
                                                    }
                                                    // 'overwrite' mode continues to process
                                                } catch (e) {
                                                    // File doesn't exist - proceed normally
                                                }
                                                
                                                if (shouldProcess) {
                                                    const compFileData = await compFile.getFile();
                                                    const compBuffer = await compFileData.arrayBuffer();
                                                    
                                                    const newCompHandle = await companionSubFolder.getFileHandle(compFile.name, { create: true });
                                                    const compWritable = await newCompHandle.createWritable();
                                                    await compWritable.write(compBuffer);
                                                    await compWritable.close();
                                                    
                                                    if (!isCopyOnly) {
                                                        await parentHandle.removeEntry(compFile.name);
                                                        logMsg('Companion', compFile.name, folderName, "Moved", 'green', newCompHandle);
                                                        compSummaryRow.Status = 'Success';
                                                        compSummaryRow.Message = '[Moved]';
                                                    } else {
                                                        logMsg('Companion', compFile.name, folderName, "Copied", 'blue', newCompHandle);
                                                        compSummaryRow.Status = 'Success';
                                                        compSummaryRow.Message = '[Copied]';
                                                    }
                                                }
                                            } catch (compErr) {
                                                logMsg('Companion', compFile.name, folderName, "Error: " + compErr.message, 'red');
                                                compSummaryRow.Status = 'Failed';
                                                compSummaryRow.Message = 'Error: ' + compErr.message;
                                            }
                                            
                                            summaryData.push(compSummaryRow);
                                        }
                                    }
                                } catch (compFolderErr) {
                                    console.error('Companion folder error:', compFolderErr);
                                }
                            }
                            // === END COMPANION FILE PROCESSING ===

                        } catch (e) {
                            logMsg(cat, row.name, row.reason, "Error Moving: " + e.message, 'red');
                            summaryRow.Status = 'Failed';
                            summaryRow.Message = "Error Moving: " + e.message;
                        }
                        
                        summaryData.push(summaryRow);
                    }
                }
                
                // Generate Summary CSV (Even if stopped)
                if (generateSummary && summaryData.length > 0) {
                     let csvContent = "FileName,OriginalPath,Category,DestinationFolder,Status,Message\n";
                     summaryData.forEach(row => {
                         const escape = (val) => `"${String(val).replace(/"/g, '""')}"`;
                         csvContent += `${escape(row.FileName)},${escape(row.OriginalPath)},${escape(row.Category)},${escape(row.DestinationFolder)},${escape(row.Status)},${escape(row.Message)}\n`;
                     });
                     
                     const blob = new Blob([csvContent], { type: 'text/csv' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     a.href = url;
                     a.download = `move-summary-${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`;
                     document.body.appendChild(a); 
                     a.click();
                     document.body.removeChild(a);
                }

            } finally {
                loading.style.display = 'none';
                stopBtn.style.display = 'none';
                // We don't auto-enable execBtn because state might need reset or re-check, 
                // but usually it's safe to re-enable if they want to try again.
                execBtn.disabled = false; 
                checkMoveReady(); // Re-verify state
            }
        });
        
        document.getElementById('stopMoveBtn').addEventListener('click', () => {
            isProcessing = false;
            // Show stopping status in all logs? Or just UI text.
            // logMsg("A", "SYSTEM", "Stopping... finishing current file...", "orange"); 
            document.getElementById('loadingText2').textContent = "Stopping...";
        });

        function logMsg(cat, name, reason, msg, color, fileHandle = null) {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.innerHTML = `<span>${name}</span> <span class="reason-tag">${reason || ''}</span> <span style="color:${color}">${msg}</span>`;
            
            if (fileHandle) {
                div.title = "Ctrl+Click to open moved file";
                div.style.cursor = "pointer";
                div.addEventListener('click', async (e) => {
                    if (!e.ctrlKey && !e.metaKey) return;
                    
                    // Add visited state
                    div.classList.add('visited');
                    
                    try {
                        const file = await fileHandle.getFile();
                        const url = URL.createObjectURL(file);
                        window.open(url, '_blank');
                    } catch (err) {
                        alert("Error opening file: " + err.message);
                    }
                });
            }

            const container = document.getElementById(`moveList${cat}`);
            if(container) {
                container.appendChild(div);
                // Update count
                logCounts[cat]++;
                document.getElementById(`logCount${cat}`).textContent = logCounts[cat];
            }
        }

        // Phase 2 Tab Switching
        window.showLogTab = function(cat) {
            ['A', 'B', 'C', 'Companion'].forEach(c => {
                const isMatch = (c === cat);
                document.getElementById(`moveList${c}`).style.display = isMatch ? 'block' : 'none';
                
                const btn = document.getElementById(`logTabBtn${c}`);
                if(isMatch) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        };

        document.getElementById('resetBtn2').addEventListener('click', () => {
            // Reload page for full clean slate
            window.location.reload();
        });

        window.toggleRow = function(rowId) {
            const row = document.getElementById(rowId);
            row.classList.toggle('collapsed');
        };

        // Check for saved session on load (must run after all functions are defined)
        (function checkSavedSession() {
            const session = loadSessionFromStorage();
            if (session && session.files && session.files.length > 0) {
                const restore = confirm(
                    `Found previous analysis session:\n` +
                    `- ${session.files.length} files analyzed\n` +
                    `- Source: ${session.sourceFolderName || 'Unknown'}\n` +
                    `- Saved: ${new Date(session.timestamp).toLocaleString()}\n\n` +
                    `Restore this session?\n\n` +
                    `(You will need to re-select the source folder)`
                );
                
                if (restore) {
                    // Restore allFiles (without handles)
                    allFiles = session.files.map(f => ({
                        name: f.name,
                        relativePath: f.relativePath,
                        category: f.category,
                        reason: f.reason,
                        handle: null,
                        parentHandle: null
                    }));
                    
                    // Display results
                    displayResults();
                    
                    // Show message to re-select folder
                    document.getElementById('sourcePathDisplay').textContent = 
                        `Previous: ${session.sourceFolderName} (re-select to proceed)`;
                } else {
                    clearSession();
                }
            }
        })();
    </script>
</body>
</html>
